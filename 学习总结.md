
# 每周抽出2-3天从头到尾过一遍自己的笔记
# 增加家里俯卧撑和深蹲计划
## 一、4.19学习总结
#### 1.  参数存在问题  (个人感觉好像用处好像不是那么大(ÒωÓױ)！)
	很多参数需要判断到底值在不在,
	   再进行下面的方法属性,因为假如为空会浏览器报错,
	
	   所以我们可以这样做一个**短路判断**
	  number&&number.foreach()  
   ``` javascript
   number&&number.foreach() 
   ```
   这样假如没值就不会往下走了  防止出错

#### 2.   flex布局问题
	工作中用到了flex,但是忘记了主轴使用方式百度了一下
![](学习总结图片/4.19/1618846488(1).jpg)


#### 3.  参数复杂
		晚上学习node.js中 发现一个假如对象太复杂可以抽出来,
	然后假如有属性不一定有的话 可以先给传入值一个ES6默认值给null  
			例如parent_id=null

​    

![](学习总结图片/4.19/1618846520(1).jpg)

## 二、4.20学习总结
#### 1. 对象嵌套复杂
		对象里面有xxx.xxx 也可以用xxx[xxx]  对象里的是变量也是不能用.需要用[][]



#### 2、跨域问题

跨域，是指**浏览器不能执行其他网站的脚本**。它是**由浏览器的同源策略造成**的，是浏览器对JavaScript实施的安全限制。

同源策略限制了一下行为：

- Cookie无法读取
- DOM 和 JS 对象无法获取
- Ajax请求发送不出去

同源是指，域名、协议、端口均为相同

**为什么需要用到跨域？**

1、自身业务是出现很多端(前后端分离开发)   2、和第三方合作  3、面试经常问

**如何处理跨域带来的ajax问题？**(解决跨域方案)

1、jsonp  

2、设置代理服务器  （正向代理，  反向代理）

3、后端设置响应头Access-Control-Allow-Origin

```
res.setHeader("Access-Control-Allow-Origin", "*")
```

跨域代码演示：

后端代码：

```js
// 入口文件
const express = require("express");

const app = express();

app.get("/get_data",(req, res)=>{
    
    res.send({name:"node", age:"11"})
})

app.listen(3001, ()=>{
    console.log(`服务器已经启动，端口为：3001`);
})
```

html代码（右键Open in Live Server）：

```html
<!--引入JQ代码-->
<script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
```

```html
<p><span id="sp1"></span>的年龄是<span id="sp2"></span></p>
<script>
    $.ajax({
        url:'http://localhost:3001/get_data',
        type:"GET",
        success: function(data){
            $("#sp1").html(data.name)
            $("#sp2").html(data.age)
        }
    });
</script>
```

这种情况是无法访问url的 因为端口不一样

####         2.2、JSONP介绍

处理使用ajax代码发起请求外，页面某些标签也会自动发起请求。我们可以利用script标签的src属性，来发起请求。

jsonp 就是前端利用 script 在页面不刷新的情况下和服务器进行交互一种技术。拿 json 格式的数据去填充一个函数，英语：json with paddding a function 简称：jsonp

######.1、使用jsonp原理来解决跨域

前端代码：
我们在前端页面里用script标签 src 来引用请求路径 只能get 请求
```html
<p><span id="sp1"></span>的年龄是<span id="sp2"></span></p>
<script>
    function callback(data){

    	console.log("执行了callback");
        $("#sp1").html(data.name)
        $("#sp2").html(data.age)
    }    
</script>
<!-- jsonp 原理，不会出现跨域-->
<script src="http://localhost:3001/get_data"></script>
```

后端代码：
这种方法需要前后端配合,前端那个请求函数叫什么,后端也得把那个函数放在send中传出来,
如这个传出来是'callback({name:"node", age:"11"})' 然后在HTML中自调用了
```js
// 入口文件
const express = require("express");

const app = express();

app.get("/get_data",(req, res)=>{
    
    // 按照jsonp原理来响应:
    res.send('callback({name:"node", age:"11"})')
})

app.listen(3001, ()=>{
    console.log(`服务器已经启动，端口为：3001`);
})
```

####         2.3、express里的jsonp
express封装好的jsonp方法
后端代码：

```js
// 入口文件
const express = require("express");

const app = express();

app.get("/get_data",(req, res)=>{

    // express封装好的方法jsonp
    res.jsonp({name:"node", age:"11"})
})

app.listen(3001, ()=>{
    console.log(`服务器已经启动，端口为：3001`);
})
```

前端代码：
这种就不需要后端要知道前端函数名字了,比较方便
```html
<script src="http://localhost:3001/get_data?callback=callback"></script>
<!--这里第一个callback是固定，=号后面的callback是我们回调函数的名字 -->
```

####         2.4、后端设置响应头

1 直接设置响应头Access-Control-Allow-Origin

设置响应头：res.setHeader("Access-Control-Allow-Origin", "*")

后端代码：

```js
const express = require("express");

const app = express();

app.get("/get_data",(req, res)=>{

    res.setHeader("Access-Control-Allow-Origin", "*")
    res.send({name:"node", age:"11"})
})

app.listen(3001, ()=>{
    console.log(`服务器已经启动，端口为：3001`);
})
```

前端代码无需任何设置。

```html
<p><span id="sp1"></span>的年龄是<span id="sp2"></span></p>
<script>
    $.ajax({
        url:'http://localhost:3001/get_data',
        type:"GET",
        success: function(data){
            $("#sp1").html(data.name)
            $("#sp2").html(data.age)
        }
    });
</script>
```

2 使用cors模块


```js
const cors = require("cors");

app.use(cors())
```


####         2.5、设置代理服务器   
以下为vuecli中配置代理的配置 ：
官方地址：

https://cli.vuejs.org/zh/config/#devserver-proxy

 

```javascript
 <!-- 在根目录添加一个  vue.config.js  文件-->
<!-- 重启项目 -->  
module.exports = {
	<!--  以下配置的效果
       “/api/getok.php”  ->   http://122.51.238.153/getok.php修改的配置 -->

  devServer: {
      proxy: {
          //如果地址以/api开头，它就会请求到 http://122.51.238.153 
          '/api': {
              target: 'http://122.51.238.153',
              changeOrigin: true,
              ws: true, 
              pathRewrite: {
   				 '^/api': '',   //重写请求路径
 			 },
          }
      }
  }
}

target：接口域名；

changeOrigin： 如果设置为true,那么本地会虚拟一个服务端接收你的请求并代你发送该请求；
ws ： 是否代理 websockets
pathRewrite：写 /api/xx/xx. 最后代理的路径就是 http://xxx.xx.com/api/xx/xx.
不对啊, 我正确的接口路径里面没有/api啊. 所以就需要 pathRewrite,用'^/api':'', 把’/api’去掉, 这样既能有正确标识, 又能在请求接口的时候去掉/api.
```



#### 3、微信小程序页面布局          

	微信小程序所有页面外层都会包裹一个page 但它没有设置高度,然后又因为微信小程序用的都是flex布局是弹性盒子,
 没有给高会根据内容撑开,所以我们需要在公共样式中设置page高度100%(宽度的话默认已经设置不需要我们写)


![](学习总结图片/4.20/1618932131(1).jpg)

## 三、 4.21学习总结

#### 1、flex布局子盒子靠右贴住(方法一无效,用法2)  
![flex float 失效了](学习总结图片/4.21/微信图片_202104211941023.png)
![所以使用margin](学习总结图片/4.21/4db742a6967e82dffa5317084d3ae00.png)

#### 2、圆角border-radious 四个角使用
![](学习总结图片/4.21/微信图片_20210421194030.png) 

#### 3、为页面添加滚动条  	
![](学习总结图片/4.21/微信图片_202104211940301.png)

#### 4、 var的声明作用域和声明提升
var的作用域是函数作用域 ,意味着在函数里面的var成为函数局部作用域, 将在函数运行结束后被摧毁,不管函数有没有被调用
![](学习总结图片/4.21/微信图片_202104211941024.png)
![结果也是报错](学习总结图片/4.21/微信图片_202104211941025.png)

var a = xxx    var a会在执行的时候提到函数最上面
![](学习总结图片/4.21/微信图片_202104211940302.png)

#### 5、 手写AJAX发送请求

 obtn.onclick = () => {

        //发送ajax请求
        // 1、创建 AJAX 对象；
        let ajax = new XMLHttpRequest();
    
        // 2、设置请求路径，请求方式等；ajax.open(请求方式，路径)
        ajax.open('GET', '/get_data');
        // 3、绑定监听状态改变的处理函数，在处理函数可获取响应数据；
        ajax.onreadystatechange = ()=>{
            // 获取响应回来的数据
            if(ajax.readyState===4&& ajax.status===200){
                console.log(ajax.readyState);
                console.log(ajax.responseText);
                // 请求到数据之后，就可以把数据更新到页面上
                odiv.innerHTML = ajax.responseText;
            }
        };
        // 4、发送请求。
        ajax.send()
    }

#### 6、 数组的join()方法  
	join() 方法用于把数组中的所有元素放入一个字符串。
	
	元素是通过指定的分隔符进行分隔的。
	在本例中，我们将创建一个数组，然后把它的所有元素放入一个字符串：
	
	<script type="text/javascript">
	
	var arr = new Array(3)
	arr[0] = "George"
	arr[1] = "John"
	arr[2] = "Thomas"
	
	document.write(arr.join())
	
	</script>
	输出：
	
	George,John,Thomas  =>()什么都不加的话默认用逗号分开 (' ')引号加一个空格就是空格分开


​	
## 四、 4.22学习总结
#### 1、函数防抖


![](学习总结图片/4.22/4e26ac68d6df8edc5e95804a037aee3.png)



#### 2、 ES6模块化引入导出方式
![](学习总结图片/4.22/7765e840dc35cca1eea1bf35be79806.png)
![](学习总结图片/4.22/f9ce46f176d792f199d5b71fb1d6fd6.png)
![](学习总结图片/4.22/05ce00ee917c9ab95c9ba183b81ccf2.png)
![](学习总结图片/4.22/335daa5ea4593278ba7bf6488c25d6b.png)
总结:默认导出不能用{}导入
 #### 3、 JavaScript substring() 方法
(a,b)截取是包括a不包括b
![](学习总结图片/4.22/0a84a7fb76fbda0701c54f9bf845d65.png)

## 五、 4.23休息

## 六、 4.24学习总结

#### 1、 对象.和[]加强理解 
  为什么要用[]  因为点运算符 例如obj.name  点运算符.后面总是字符串不能是变量[]里面就可以
  对象的属性属性名都是字符串格式或者数字模式
  所以[]里面填的值,如果没有特殊是变量 想这样获取必须加""因为是字符串

#### 2、 面试之函数的节流 
```js
function throttle(callback, wait){
    //定义开始时间
    let start = 0;
    //返回结果是一个函数
    return function(e){
        //获取当前的时间戳
        let now = Date.now();
        //判断
        if(now - start >= wait){
            //若满足条件, 则执行回调函数
            callback.call(this, e);
            //修改开始时间
            start = now;
        }
    }
}



```


## 七、 4.25学习总结
今天本来学了一晚上但是学着学着突然改变了学习计划,本来是准备看好尚硅谷的VUE源码的,听的太吃力了,然后准备从今天开始为期2个月看一个,
瓜哇教育的进阶视频,所以笔记不多,第一天的瓜哇也没看完,因为时间不够,给自己来个100天挑战吧,希望100天以后可以更强
(100天争取看好珠峰JS+vue)

#### 1、面试之手写call()
```
export function call(Fn, obj, ...args){
    //判断
    if(obj === undefined || obj === null){
        obj = globalThis;// 全局对象
    }
    //为 obj 添加临时的方法
    obj.temp = Fn;
    //调用 temp 方法
    let result = obj.temp(...args);
    //删除 temp 方法
    delete obj.temp;
    //返回执行结果
    return result;
}


```



## 八、 4.26学习总结
瓜哇教育取消,因为感觉课程不怎么样,绝对开启珠峰JS希望顺利
获取属性名对应的属性值
=>对象.属性名
=>对象[属性名]  属性名是数字或者字符串格式的
=>如果当前属性名不存在，默认的属性值是undefined
=>如果属性名是数字，则不能使用点的方式获取属性值
数组是特殊的对象
   1. 我们中括号中设置的是属性值，它的属性名是默认生成的数字，从零开始递增，而且这个数字代表每一项的位置，我们把其成为“索引” =>从零开始，连续递增，代表每一项位置的数字属性名
   2. 天生默认一个属性名 length ，存储数组的长度
   3. 由此可以得出什么,对象获取属性用obj.xx 或者Obj[xx],数组又是特殊的对象,属性值是默认从0生成的,所以获取对象的值是arr[0]这种方式
## 九、 4.27学习总结(珠峰JS第二天了)
## 
#### 1、基本类型和引用类型
let a = 123 三步骤 先创建变量a 再创建值123 最后再关联
a.x = a = {n:2} 这是先 a,x与{n:2} 关联  然后再让a与{n:2}关联起来
对象也是一样的原理 
下面用2张 周老师画图增加理解
![](学习总结图片/4.27/数据类型之间的区别.png)
![](学习总结图片/4.27/阿里的面试题.png)
#### 2、 加法操作符的转换  数字和字符串和对象null和undefined和数组的互相转换
一道腾讯关于转换的面试题
JS中的加减乘除本应是进行数学运算（如果遇到的值不是数字类型，也需要基于Number()方法把其转换为数字，再进行运算）；
但是JS中加法有特殊情况：相加过程中遇到字符串直接变为字符串拼接,加法中没遇到字符串那就正常转换成数字来相加
1. Number()它是按照浏览器从底层机制，把其它数据类型转换为数字
- 字符串：看是否包含非有效数字字符,包含结果就是NaN；'  '->0；
- 布尔：true->1  false->0
- null：->0
- undefined：->NaN
- 引用类型值都要先转换为字符串再转换为数字
	+ {}/正则/函数等  ->NaN
	+ [] ->'' ->0
	+ ['12'] ->'12' ->12
	+ [12,23] ->'12,23' ->NaN
- ...

2. parseInt/parseFloat([val]) 遵循**按照字符串**从左到右查找的机制找有效数字字符（**所以传递的值一定是字符串，不是也要转换为字符串然后在查找**）
- parseInt(undefined) ->parseInt('undefined') ->NaN
- parseInt('  ') ->NaN  因为没找到有效数字字符
parseInt()函数 更专注于字符串是否包含数值模式。字符串最前面的空格会被忽 略，
从第一个非空格字符开始转换。如果第一个字符不是数值字 符、加号或减号，parseInt()立即返回NaN。
这意味着空字符串也 会返回NaN（这一点跟Number()不一样，它返回0）

![](学习总结图片/4.27/20fd8491ff6dcc4afb4427af72ad266.png)
![](学习总结图片/4.27/795c1c1e2d5364433e515bc0036e533.png)
![](学习总结图片/4.29/1619711148(1).jpg)
![](学习总结图片/4.29/1619711182(1).jpg)
![](学习总结图片/4.27/1619535015(1).jpg)
![](学习总结图片/4.27/1619535063(1).jpg)
![](学习总结图片/4.27/1619538430(1).jpg)
```
var a = 'abc' + 123 + 456;
var b = '456' - '123';
/* 相加的时候如果有任一操作数是NaN，则返回NaN；
undefined转换成数字是NAN */
/* 如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。这里[].toString为空 */
var c = 100 + true + 21.2 + null + undefined + "Tencent" + [] + null + 9 + false;
console.log(a,b,c); //abc123456 333 NaNTencentnull9false
```

#### 3、浏览器输出颜色
浏览器控制台输出的颜色


**蓝色的是数字,黑色的是字符串**

![](学习总结图片/4.27/8f5e01b68bf61fa34c956da777c4fee.png)



#### 4、typeof
  **typeof是一个运算符**
![](学习总结图片/4.27/d045dde33115a4f9144c2d0f71b41bc.png)

#### 5、三元运算符
简单的用三元
![](学习总结图片/4.27/1619535838(1).jpg)



#### 6、switch

![](学习总结图片/4.27/1619535890(1).jpg)
![](学习总结图片/4.27/1619535954(1).jpg)
**这里等价于a=1或者a=5时候 a+=2**
case得等于是默认全等===,所以有时候if的时候你用的是==,要注意区分

#### 7、z-index
当一个盒子是**父元素的子盒子**时候,想用父元素遮住子元素,只能让子元素z-index等于负数,
如果设置父元素z-index=1,子元素也会**继承**,那设置就没意义了
![](学习总结图片/4.27/731346e1d973a2f02d5d07bf255303a.png)
![](学习总结图片/4.27/b106a09e70ff54865236ff9a08ee47a.png)
![](学习总结图片/4.27/f86df0ceab9d500ac00ddf57b05b5a5.png)

#### 8、关于样式名字的问题
关于样式 html代码片段中用的是**xx-xx**  JS用的是**驼峰命名**
![](学习总结图片/4.27/912c7cdcdfae6a73e472f510a03204b.png)
![](学习总结图片/4.27/0ee08b68e1dc6b755ec42be90ca905e.png)


#### 9、关于JS修改HTML样式
通过 xxx.style.width 获取某样式的时候  HTML中行内必须要本来就有width样式.
元素对象.style.xxx=xxx 修改元素的某一个样式值（操作的是元素行内样式，
所以如果我们没有把样式写在行内上，在JS中基于.style.xxx的方式是无法获取到样式的）
![](学习总结图片/4.27/1619536585(1).jpg)


#### 10、break和continue

循环关键字break是直接退出下面代码什么也不执行 i++也不执行 


continue是后面代码不执行 i++是会执行的

![](学习总结图片/4.27/1619536786(1).jpg)
## 十、 4.28学习总结(加班到1点没学习)
   今天写项目,自己太急了,很多东西都没注意,还是太着急,需要静心!还有代码写的还是不够优雅!!!!
   代码还有很长的路需要走,加油郑杰!

## 十一、4.29学习总结
#### 1、获取DOM节点后,节点对象的属性
![](学习总结图片/4.29/1619710384(1).jpg)

#### 2、通过getElementsByTagName  
![](学习总结图片/4.29/27621f74ffcfb4c8c9bc425b768f8f7.png)


#### 3、了解console.log
console.log() 分析 为什么xx.xx 因为console是一个**对象**log是他的属性值 
所以用console.log 为什么还有个() **因为log这个属性的值是一个函数**所以需要()来执行 和传参 也叫方法(对象里面的属性值是函数的叫方法)

#### 4、JS的赋值问题
JS中值的赋值并不是单纯的赋值 而是**让变量和内存中的值进行关联**  JS是**关联赋值**
![](学习总结图片/4.29/0183cbe22e06656537689d17bb74ee1.png)
13并没有覆盖掉12,因为一开始是我们在栈内存中创建一个值12和a关联,
然后a=13又在栈内存中创建一个值13和a关联,并没有删除掉12


#### 5、腾讯面试题之NAN
![](学习总结图片/4.29/78be2b9fdda61081dfa151aac038108.png)
1. NAN与任何数字都不相等与本身都不相等
2. type of NAN 结果是number
3. parseInt转换如果遇到非数字直接NAN,但遇到123ABC换转换成123   , ABC123则不行 因为遇到非数字就报NAN
4. 关于isNaN
![](学习总结图片/4.29/1619711359(1).jpg)


#### 6、重要编程思想,自定义属性
![](学习总结图片/4.29/1619711491(1).jpg)

#### 7、css  移动问题 
如果想让元素相对自己原来位置移动 就加一个相对定位relative  
然后让left top等值调整位置,且移动后元素会覆盖其他盒子的样式
例子:
![](学习总结图片/4.29/7b28b0b721b42c2db6c19b6e0eb4d94.png)
原来有重叠部分,给上面小盒子设置
![](学习总结图片/4.29/cee41b37f2d43a4761657e6c321f6c4.png)
![](学习总结图片/4.29/1619711674(1).jpg)


#### 8、css中class选择问题
CSS中要选择当前div里面的class要连着写
![](学习总结图片/4.29/c9aeeb9eb66fd2c9e597c482d291e70.png)
div与.active 不能有空格 有空格就变成div子元素的.active了  
 连着写是表示div中的.active
 ![](学习总结图片/4.29/28f1ce061bcebe444c117955028ed15.png)


#### 9、解构赋值重命名
![](学习总结图片/4.29/358fca8d6222063c133b97fb035db6d.png)


#### 10、CSS奇数偶数行
CSS实现隔行变色  even偶数行   odd奇数行
![](学习总结图片/4.29/0d8a3242892c3f0435eeabc0cdc4090.png)

#### 11、取余数计算概念
小的数除以大的数余数就是小的数本身

#### 12、函数的形参
![](学习总结图片/4.29/4a8cca5d1473d468c976ae845ce143c.png)

**设置了形参没传,会默认undefined,所以我们需要在函数里面处理**,
判断假如没有传我们要设置形参为多少,判断这个最好用=== 因为2等会出现隐性转换,会不够精确, 
 ES6中可以直接在形参后面m=1直接写 就是没传等于1


#### 13、浏览器控制台打印问题(了解)
![](学习总结图片/4.29/95afb5052ccfed13b536eaa618cd2d0.png)
为什么控制台会打印东西或者输入什么东西 明明有结果还是返回一个undefined
因为浏览器是一个整体 如果有括号就把他们当成函数来执行了  **函数里面如果里面没有return 就会默认返回undefined**
例如 alert(1) 这就是一个window对象的一个方法该方法是一个函数所以用()调用,但是该函数没有返回值,就会默认返回undefined
所以是undefined

#### 14、函数的return问题
函数的返回值一定是一个值,如果是一个函数那就是把存储函数的值返回出去
如图里面返回一个函数f,只是把指向函数的地址的值返回出去
![](学习总结图片/5.11/1620734616(1).jpg)
![](学习总结图片/4.29/5b92c40a3ed4d490bcc974021f3f34a.png)
return是指当前函数中return**后面所有代码都不执行了**,退出函数了
![](学习总结图片/4.29/ff59775f3e5f39a89a6535cff994a7a.png)


**函数没有写return默认返回undefined**


#### 14、匿名函数
![](学习总结图片/4.29/6db4bacc8595ac3399ee73e9d974ed1.png)

#### 15、常用的输出方式
![](学习总结图片/4.29/1619713555.jpg)

#### 16、几维的理解
![](学习总结图片/4.29/1619713619(1).jpg)
几维数组,就是外面一个数组里面包了多少对象或者数组就是几维
对象同数组

#### 17、script 位置问题
![](学习总结图片/4.29/1619713709(1).jpg)

#### 18、console.log(alert(1))问题
console.log(alert(1))  
1. alert(1)：执行浏览器内置的alert方法，执行方法的时候弹出一个"1"(方法的功能)，此方法没有返回值（默认返回值undefined）
2. console.log(undefined)





## 十二、4.30学习总结
周五休息 打游戏


## 十三、5.1学习总结
坐车的一天

#### 1、点击切换背景颜色的2种方式
1. 普通版    ![](学习总结图片/5.1/1619850881(1).jpg)
2. 函数数组思想法   ![](学习总结图片/5.1/1619850986(1).jpg)

#### 2、++运算和普通加运算字符串的区别
![](学习总结图片/5.1/1619851138(1).jpg)
++是纯粹的数字计算不会字符串拼接

#### 3、substring和slice和substr区别
![](学习总结图片/5.1/slice,substring,substr区别1.jpg)
![](学习总结图片/5.1/slice,substring,substr区别2.jpg.jpg)
slice,substring正数的时候都是从几到几不包括后面那个
substr第二个参数是表示我们要截取几个
负数的情况substring全部当0处理
substr第一个是字符串长度相减,第二个当0
slice是第一第二参数都是字符串长度和负数想减
// slice 和 substring;substring如果后面小,会自动掉成0,7   slice不会,slice返回空字符串
 console.log(a.slice(7,0));
 console.log(a.substring(7,0));
#### 4、对象的又一次加强理解
![](学习总结图片/5.1/1619858330(1).jpg)

![](学习总结图片/5.1/1619884017(1).jpg)
和ES6语法一起理解一下

#### 5、for-in理解
![](学习总结图片/5.1/1619884138(1).jpg)
ECMAScript中对象的属性是无序的，因此for-in语句**不能保证返回对象 属性的顺序**。
换句话说，所有可枚举的属性**都会返回一次**，但返回的顺 序可能会因浏览器而异。

## 十四、5.2学习总结

#### 1、自定义属性编程思想(又一次)
![](学习总结图片/5.2/61ab0f62eefa1399e1d64faaa9b312f.png)
![](学习总结图片/5.2/深刻理解元素对象和元素对象集合.png)

#### 2、函数的运行机制
![](学习总结图片/5.2/函数的深入理解.png)
res = null 表示res和谁都不关联 空指针

函数只创建不执行可以吗 可以 只是没意义 报错吗 不报错 因为创建的时候只是开了一个堆 把函数里面的代码当成字符串存起来了
 所以FN代表当前函数本身 FN()代表当前函数执行 具体代表return后面的值 
 函数执行一定得有结果吗 那个结果就是return后面的值 
 想看一个函数的返回的值是谁 只要看return后面的值 
 如果有return后面是啥就是啥 没有return就是undefined
 函数每次执行都是把代码从头来一遍 
 每一次都是形成一个全新的私有栈内存 
 外面想用只能函数本身return出去

#### 3、自定义属性编程属性加函数的运行机制(通过选项卡)
![](学习总结图片/5.2/1619935911(1).jpg)
![](学习总结图片/5.2/选项卡运行原理图.png)

#### 4、函数的arguments
![](学习总结图片/5.2/1619938624.jpg)

#### 5、箭头函数(初体验)
有的时候可能会看到=>xx=>xx其实是这样的
![](学习总结图片/5.2/1619940302(1).jpg)

...arg运算符  箭头函数里面没有arguments但是有...arg  这个arg不是伪数组  可以直接用数组的方法
![](学习总结图片/5.2/1619940473(1).jpg)

#### 6、如何基于Math.max/min获取数组中的最大值最小值？
1 . Math.min.apply(null, arr)

>>>Math.min.apply(null, [2,1,3])
<<<1

唉？不是不能接收数组类型的参数吗？这是apply方法的特性，apply方法第二个参数为参数的数组，明白了吧，虽然我们传入的是数组参数，但是apply会将数组拆分并传入调用的函数。可以说是比较巧的用法了。

2 . Math.min(...[v1, v2...])

>>>Math.min(...[2,1,3])
<<<1

这里的…（三个点）是ES6中的用法，有兴趣的可以去了解一下，低版本的JS并不支持这种用法。

#### 7、Math的常用方法
1.  Math.abs([number value])       ![](学习总结图片/5.2/1619954644.jpg)

2.  Math.ceil **(向上取整)(ceil就是要比原来的数大)**/ floor**(向下取整)(floor要比原来的数小)**([number value])   (ceil就是要比原来的数大)  ![](学习总结图片/5.2/1619954709(1).jpg)

3.  Math.round() (四舍五入)    ![](学习总结图片/5.2/1619954763(1).jpg)


4.  Math.max / min ([val1],[val2],...)     > 获取一堆数中的最大值和最小值   



5. Math.sqrt / pow()



> sqrt：给一个数开平方
>
> pow：计算一个数的多少次幂
```javascript
console.log(Math.sqrt(9)); //=>3  符合N*N=M 这样的M才能整开平方
console.log(Math.sqrt(-9)); //=>NaN 负数开不了平方
console.log(Math.pow(2, 10)); //=>1024
```

6. Math.random()

> 获取0~1之间的随机小数

```javascript
for (let i = 1; i <= 10; i++) {
	console.log(Math.random());
}
/*
 * 0.09453770227521763
 * 0.06700581113042259
 * 0.10092020814995206
 * ...
 */
```

#### 8、随机获取(n~m)中的随机整数
扩展：获取 [n~m] 之间的随机整数

> 包含n也包含m
>
> n<m
```javascript
Math.round(Math.random()*(m-n)+n)
```

#### 9、数组的常用方法改变原数组的增删改查
> 这一部分方法都会修改原有的数组
**1.实现数组增删改的方法**
`push`     也可以用原生实现ary[ary.length]

```javascript
/*
 * push : 向数组末尾增加内容
 * @params
 *   多个任意类型
 * @return
 *   新增后数组的长度 
 */
let ary = [10, 20];
let res = ary.push(30, 'AA');
// 基于原生JS操作键值对的方法，也可以向末尾追加一项新的内容
ary[ary.length] = 40;
console.log(res, ary); //=>4 [10,20,30,'AA',40]
```

`unshift`    不可以用原生 但是可以用ES6...展开运算符

```javascript
/*
 * unshift : 向数组开始位置增加内容
 * @params
 *   多个任意类型
 * @return
 *   新增后数组的长度 
 */
let ary = [10, 20];
let res = ary.unshift(30, 'AA');
console.log(res, ary); //=>4  [30,'AA',10,20]

// 基于原生ES6展开运算符，把原有的ARY克隆一份，在新的数组中创建第一项，其余的内容使用原始ARY中的信息即可，也算实现了向开始追加的效果
ary = [100, ...ary];
console.log(ary); //=>[100,30,'AA',10,20]
```

`shift`   基于原生的不能实现

```javascript
/*
 * shift : 删除数组中的第一项
 * @params
 * @return
 *   删除的那一项 
 */
let ary = [10, 20, 30, 40];
let res = ary.shift();
console.log(res, ary); //=>10  [20, 30, 40]

// 基于原生JS中的DELETE，把数组当做普通的对象，确实可以删除掉某一项内容，但是不会影响数组本身的结构特点（length长度不会跟着修改）,真实项目中杜绝这样的删除使用
delete ary[0];
console.log(ary); //=>{1:30,2:40,length:3}
```

`pop`   可以原生实现

```javascript
/*
 * pop : 删除数组中的最后一项
 * @params
 * @return
 *   删除的那一项 
 */
let ary = [10, 20, 30, 40];
let res = ary.pop();
console.log(res, ary); //=>40  [10,20,30]

// 基于原生JS让数组数组长度干掉一位，默认干掉的就是最后一项
ary.length--; //=>ary.length = ary.length - 1;
console.log(ary);
```

`splice`

```javascript
/*
 * splice : 实现数组的增加、删除、修改
 * @params
 * 	 n,m 都是数字  从索引n开始删除m个元素（m不写，是删除到末尾）
 * @return
 *   把删除的部分用新数组存储起来返回 
 */
let ary = [10, 20, 30, 40, 50, 60, 70, 80, 90];
let res = ary.splice(2, 4);
console.log(res, ary); //=>[30, 40, 50, 60]  [10, 20, 70, 80, 90]

// 基于这种方法可以清空一个数组，把原始数组中的内容以新数组存储起来（有点类似数组的克隆：把原来数组克隆一份一模一样的给新数组）
/* res = ary.splice(0);
console.log(res, ary);//=>[10, 20, 70, 80, 90] [] */

// 删除最后一项和第一项
ary.splice(ary.length - 1);
ary.splice(0, 1);
console.log(ary);
```

```javascript
/*
 * splice : 实现数组的增加、修改
 * @params
 * 	 n,m,x  从索引n开始删除m个元素，用x占用删除的部分
 *   n,0,x  从索引n开始，一个都不删，把x放到索引n的前面
 * @return
 *   把删除的部分用新数组存储起来返回 
 */
let ary = [10, 20, 30, 40, 50];
let res = ary.splice(1, 2, '珠峰培训', '哈哈哈');
console.log(res, ary); //=> [20,30] [10,'珠峰培训','哈哈哈', 40, 50]

// 实现增加
//单纯的增加是索引前面那个位置,比如从索引3开始删除0个那就是索引3的值40前面增加呵呵呵
ary.splice(3, 0, '呵呵呵');
console.log(ary); //=>[10, "珠峰培训", "哈哈哈", "呵呵呵", 40, 50]

// 向数组末尾追加
ary.splice(ary.length, 0, 'AAA');

// 向数组开始追加
ary.splice(0, 0, 'BBB');
```


## 十五、5.3学习总结(劳动节忙学的少)

#### 1、数组常用的查询和拼接
**2.数组的查询和拼接**
> 此组学习的方法，原来数组不会改变

`slice`

```javascript
/*
 * slice : 实现数组的查询
 * @params
 * 	 n,m 都是数字 从索引n开始，找到索引为m的地方（不包含m这一项）
 * @return
 *   把找到的内容以一个新数组的形式返回 
 */
let ary = [10, 20, 30, 40, 50];
let res = ary.slice(1, 3);
console.log(res); //=>[20,30]

// m不写是找到末尾
res = ary.slice(1);
console.log(res); //=>[20, 30, 40, 50]

// **数组的克隆，参数0不写也可以**
res = ary.slice(0);
console.log(res); //=>[10, 20, 30, 40, 50]

// 思考：1.如果n/m为负数会咋地，如果n>m了会咋地，如果是小数会咋地，如果是非有效数字会咋地，如果m或者n的值比最大索引都会咋地？ 2.这种克隆方式叫做浅克隆，可以回去先看看深度克隆如何处理!
```

`concat`

```javascript
/*
 * concat : 实现数组拼接
 * @params
 * 	 多个任意类型值
 * @return
 *   拼接后的新数组（原来数组不变） 
 */
let ary1 = [10, 20, 30];
let ary2 = [40, 50, 60];
let res = ary1.concat('珠峰培训', ary2);
console.log(res);
```

**3.把数组转换为字符串**

> 原有数组不变

`toString`

```javascript
/*
 * toString : 把数组转换为字符串
 * @params
 * @return
 *   转换后的字符串，每一项用逗号分隔（原来数组不变） 
 */
let ary = [10, 20, 30];
let res = ary.toString();
console.log(res); //=>"10,20,30"
console.log([].toString()); //=>""
console.log([12].toString()); //=>"12"
```

`join`

```javascript
/*
 * join : 把数组转换为字符串
 * @params
 *   指定的分隔符（字符串格式）
 * @return
 *   转换后的字符串（原来数组不变） 
 */
let ary = [10, 20, 30];
let res = ary.join('');
console.log(res); //=>"102030"

res = ary.join();
console.log(res); //=>"10,20,30"

res = ary.join('|');
console.log(res); //=>"10|20|30"

res = ary.join('+');
console.log(res); //=>"10+20+30"
console.log(eval(res)); //=>60  eval把字符串变为JS表达式执行
```

**4.检测数组中的是否包含某一项**

`indexOf / lastIndexOf / includes`

```javascript
/*
 * indexOf / lastIndexOf : 检测当前项在数组中第一次或者最后一次出现位置的索引值（在IE6~8中不兼容）
 * @params
 *   要检索的这一项内容
 * @return
 *   这一项出现的位置索引值（数字），如果数组中没有这一项，返回的结果是-1
 * 原来数组不变
 */
let ary = [10, 20, 30, 10, 20, 30];
console.log(ary.indexOf(20)); //=>1
console.log(ary.lastIndexOf(20)); //=>4

// 想验证ARY中是否包含'珠峰培训'
if (ary.indexOf('珠峰培训') === -1) {
	// 不包含
}
// 也可以直接使用ES6新提供的includes方法判断
if (ary.includes('珠峰培训')) {
	// 包含：如果存在返回的是TRUE
}
```

**5.数组的排序或者排列**

`reverse`

```javascript
/*
 * reverse : 把数组倒过来排列
 * @params
 * @return
 *   排列后的新数组
 * 原来数组改变
 */
let ary = [12, 15, 9, 28, 10, 22];
ary.reverse();
console.log(ary); //=>[22, 10, 28, 9, 15, 12]
```

`sort`

```javascript
/*
 * sort : 实现数组的排序
 * @params
 *   可以没有，也可以是个函数
 * @return
 *   排序后的新数组
 * 原来数组改变
 */
let ary = [7, 8, 5, 2, 4, 6, 9];
ary.sort();
console.log(ary); //=>[2, 4, 5, 6, 7, 8, 9]

// SORT方法中如果不传递参数，是无法处理10以上数字排序的(它默认按照每一项第一个字符来排，不是我们想要的效果)
/* ary = [12, 15, 9, 28, 10, 22];
ary.sort();
console.log(ary); //=> [10, 12, 15, 22, 28, 9] */

// 想要实现多位数正常排序，需要给SORT传递一个函数，函数中返回 a-b 实现升序，返回 b-a 实现降序
ary = [12, 15, 9, 28, 10, 22];
// ary.sort(function(a,b){ return a-b; });
ary.sort((a, b) => a - b);
console.log(ary);
```

**6.遍历数组中每一项的方法**

`forEach`

```javascript
/*
 * forEach：遍历数组中的每一项内容
 * @params
 *    回调函数
 * @return
 * 
 * 原来数组不变 
 */
let ary = [12, 15, 9, 28, 10, 22];

/* // 基于原生JS中的循环可以实现
for (let i = 0; i < ary.length; i++) {
	// i:当前循环这一项的索引
	// ary[i]:根据索引获取循环的这一项
	console.log('索引：' + i + ' 内容：' + ary[i]);
} */

ary.forEach((item, index) => {
	// 数组中有多少项，函数就会被默认执行多少次
	// 每一次执行函数：item是数组中当前要操作的这一项，index是当前项的索引
	console.log('索引：' + index + ' 内容：' + item);
});
```



## 十六、5.4学习总结(劳动节参加婚礼没有学习)

## 十七、5.5学习总结(回来杭州站票直接累的困死)
5.6号开始一定要全力以赴

## 十八、5.6号学习总结(五月份,活是真的多,很忙,但是也要加油)

#### 1、数组去重的稍微笨重的方法
方案一
这个方案和indexOf==-1,差不多的,但是这里有一个**if 加continue 的思路**可以学习

```javascript
/*
 * 方案一：
 *   循环原有数组中的每一项，每拿到一项都往新数组中添加
 *   添加之前验证新数组中是否存在这一项，不存在再增加
 */
let newAry = [];
for (let i = 0; i < ary.length; i++) {
	// 循环获取原有数组中的每一项
	let item = ary[i];
	// 验证新数组中是否存在这一项
	if (newAry.includes(item)) {
		// 存在这一项，不在增加到新数组中，继续下一轮循环即可
		continue;
	}
	// 新数组中不存在这一项，我们加入到新数组中即可
	newAry.push(item);
}
console.log(newAry);
```

```javascript
//简化代码
let newAry = [];
ary.forEach(item => {
	if (newAry.includes(item)) return;
	newAry.push(item);
});
console.log(newAry);
```

方案二
这个方案需要运用2个循环 进行前后对比,然后运用splice方法删除重复项,但是会出现**数组塌陷**的问题,
但是没有兼容性问题了(虽然现在也已经抛弃IE6,7,8了)
```javascript
/*
 * 方案二：
 *  先分别拿出数组中的每一项A
 *  用这一项A和“它后面的每项”依次进行比较，如果遇到和当前项A相同的，则在原来数组中把这一项移除掉
 * 
 * 不用includes/indexOf（这样保证兼容性）
 */
var ary = [1, 2, 3, 1, 2, 1, 2, 3, 2, 1, 2, 3];
for (var i = 0; i < ary.length; i++) {
	// item：每一次循环拿出来的当前项
	// i：当前项的索引  i+1：代表后一项
	var item = ary[i];
	// 让当前项和后面的每一项进行比较(循环)
	for (var j = i + 1; j < ary.length; j++) {
		// compare：后面拿出来要比较的每一项
		var compare = ary[j];
		// 如果compare和item相等，说明这一项是重复的，我们把它删掉
		if (compare === item) {
			// j索引这一项要从数组中移除
			ary.splice(j, 1);
			// 数组塌陷了：j后面的每一项索引都提前了一位，下一次要比较的应该还是j这个索引的内容
			j--;
		}
	}
}
console.log(ary);
```

#### 2、数组去重比较好的办法(封装了一个去重函数)

1. 方案一 运用了对象没有重复的键的特点,用**数组的值当对象的键值对(键和值是相等的)**
```javascript
let ary = [1, 2, 3, 1, 2, 1, 2, 3, 2, 1, 2, 3];
// 1.创建一个空对象
let obj = {};
// 2.循环数组中的每一项，把每一项向对象中进行存储 => item:item
for (let i = 0; i < ary.length; i++) {
	let item = ary[i];
	// 3.每一次存储之前进行判断:验证obj中是否存在这一项
	if (obj[item] !== undefined) {
		// 已经存在这一项
		ary.splice(i, 1);
		i--;
		continue;
	}
	obj[item] = item;
}
console.log(ary);
```

> 基于splice实现删除性能不好：当前项被删后，后面每一项的索引都要向前提一位，**如果后面内容过多，一定影响性能**
> 方案二 用了一个小技巧 **把删除的索引位置和值换成数组最后一项**

```javascript
/*
 * unique：实现数组去重的方法
 *  @params
 *     ary [Array] 要去重的数组
 *  @return
 *     [Array] 去重后的数组
 * by zhouxiaotian on 20190724   
 */
function unique(ary) {
	let obj = {};
	for (let i = 0; i < ary.length; i++) {
		let item = ary[i];
		if (obj[item] !== undefined) {
			ary[i] = ary[ary.length - 1];
			ary.length--;//就是把最后一项删除,方法很多也可以用pop
			i--;
			continue;
		}
		obj[item] = item;
	}
	return ary;
}
let aa = [12, 23, 12, 15, 25, 23, 25, 14, 16];
aa = unique(aa);
aa.sort((a, b) => a - b);
console.log(aa); //=>[12, 14, 15, 16, 23, 25]
```


#### 3、数组去重ES6简便方法
**基于ES6的Set（对应的Map）实现去重**
let ary = [12, 23, 12, 15, 25, 23, 25, 14, 16];
ary = [...new Set(ary)];   先用Set获得一个去重的数组对象,然后用扩展运算符变成真数组,记得要用[]包起来

console.log(ary);

#### 4、字符串常用方法
**字符串的方法都是复制出值,不会对原来的字符串进行修改**

> 所有用 单引号、双引号、反引号 包起来的都是字符串

**字符串也有索引和length**
```javascript
let str = 'zhufengpeixunyangfanqihang';
// 每一个字符串都是由零到多个字符组成的
str.length //=>字符串长度
str[0] //=>获取索引为零（第一个）字符
str[str.length-1] //=>获取最后一个字符str.length-1最后一项索引
str[10000] //=>undefined 不存在这个索引

//循环输出字符串中的每一个字符
for (let i = 0; i < str.length; i++) {
	let char = str[i];
	console.log(char);
}
```

`charAt / charCodeAt`
charCodeAt不常用
charAt：**根据索引获取指定位置的字符**
**与str[xx]区别是charAt(xx)假如没有这个索引返回空字符串'',str[xx]没有返回undefined**

```javascript
/*
 * charAt：根据索引获取指定位置的字符
 * charCodeAt：获取指定字符的ASCII码值（Unicode编码值）
 *  @params
 * 	   n [number] 获取字符指定的索引
 *  @return 
 *     返回查找到的字符
 *     找不到返回的是空字符串不是undefined，或者对应的编码值 
 */
let str = 'zhufengpeixunyangfanqihang';
console.log(str.charAt(0)); //=>'z'
console.log(str[0]); //=>'z'
console.log(str.charAt(10000)); //=>''
console.log(str[10000]); //=>undefined
console.log(str.charCodeAt(0)); //=>122
console.log(String.fromCharCode(122)); //=>'z'
```

`substr / substring / slice`

```javascript
/*
 * 都是为了实现字符串的截取（在原来字符串中查找到自己想要的）
 * 	 substr(n,m)：从索引n开始截取m个字符，m不写截取到末尾（后面方法也是）
 *   substring(n,m)：从索引n开始找到索引为m处(不含m)
 *   slice(n,m)：和substring一样，都是找到索引为m处，但是slice可以支持负数作为索引，其余两个方法是不可以的
 */
let str = 'zhufengpeixunyangfanqihang';
console.log(str.substr(3, 7)); //=>'fengpei'
console.log(str.substring(3, 7)); //=>'feng'
console.log(str.substr(3)); //=>'fengpeixunyangfanqihang' 截取到末尾
console.log(str.substring(3, 10000)); //=>'fengpeixunyangfanqihang' 截取到末尾（超过索引的也只截取到末尾）

console.log(str.substring(3, 7)); //=>'feng'
console.log(str.slice(3, 7)); //=>'feng'
console.log(str.substring(-7, -3)); //=>'' substring不支持负数索引
console.log(str.slice(-7, -3)); //=>'nqih' slice支持负数索引 =>快捷查找：负数索引，我们可以按照 STR.LENGTH+负索引 的方式找   =>slice(26-7,26-3)  =>slice(19,23)
```

`indexOf / lastIndexof / includes`

```javascript
/*
 * 验证字符是否存在
 * 	 indexOf(x,y)：获取x第一次出现位置的索引，y是控制查找的起始位置索引
 *   lastIndexOf(x)：最后一次出现位置的索引
 *   =>没有这个字符，返回的结果是-1
 *includes() 方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。
 *注意： includes() 方法区分大小写。
 */
let str = 'zhufengpeixunyangfanqihang';
console.log(str.indexOf('n')); //=>5
console.log(str.lastIndexOf('n')); //=>24

console.log(str.indexOf('@')); //=>-1 不存在返回-1
if (str.indexOf('@') === -1) {
	// 字符串中不包含@这个字符
}

console.log(str.indexOf('feng')); //=>3  验证整体第一次出现的位置，返回的索引是第一个字符所在位置的索引值
console.log(str.indexOf('peiy')); //=>-1

console.log(str.indexOf('n', 7)); //=>12 查找字符串索引7及之后的字符串中，n第一次出现的位置索引	

if (!str.includes('@')) {
	console.log('当前字符串不包含@');
}
```

`toUpperCase / toLowerCase`

```javascript
/*
 * 字符串中字母的大小写转换
 * 	 toUpperCase()：转大写
 *   toLowerCase()：转小写
 */
let str = 'ZhuFengPeiXunYangFanQiHang';
str = str.toUpperCase();
console.log(str); //=>'ZHUFENGPEIXUNYANGFANQIHANG'

str = str.toLowerCase();
console.log(str); //=>'zhufengpeixunyangfanqihang'

// 实现首字母大写
str = str.substr(0, 1).toUpperCase() + str.substr(1);
console.log(str); //=>'Zhufengpeixunyangfanqihang'
```

`split`

```javascript
/*
 * split([分隔符]):把字符串按照指定的分隔符拆分成数组（和数组中join对应）
 * 
 * split支持传递正则表达式 
 */
// 需求：把|分隔符变为,分隔符
let str = 'music|movie|eat|sport';
let ary = str.split('|'); //=>["music", "movie", "eat", "sport"]
str = ary.join(',');
console.log(str); //=>"music,movie,eat,sport"
```

`replace`
**replace只会替换第一次出现的,所以需要配合正则比较好用**
```javascript
/*
 * replace(老字符,新字符)：实现字符串的替换（经常伴随着正则而用）
 */
let str = '珠峰@培训@扬帆@起航';
// str = str.replace('@', '-');
// console.log(str); //=>"珠峰-培训@扬帆@起航" 在不使用正则表达式的情况下，执行一次REPLACE只能替换一次字符

str = str.replace(/@/g, '-');
console.log(str); //=>珠峰-培训-扬帆-起航
```
还有一些方法,以后慢慢学
`match`

`localCompare`

`trim / trimLeft / trimRight`

...

控制台输出 String.prototype 查看所有字符串中提供的方法


## 十九、5.7号学习总结(状态好像不是很好!!!下半场加油)

#### 1、分装一个获取url参数的函数


```javascript
/* 
 * queryURLParams：获取URL地址中问号传参的信息和哈希值
 *   @params
 *      url [string] 要解析的URL字符串
 *   @return
 *      [object] 包含参数和哈希值信息的对象
 * by zhouxiaotian on 2019/07/24 16:29:00
 */
function queryURLParams(url) {
	//1.获取?和#后面的信息
	let askIn = url.indexOf('?'),
		wellIn = url.indexOf('#'),
		askText = '',
		wellText = '';
	// #不存在
	wellIn === -1 ? wellIn = url.length : null;
	// ?存在
	askIn >= 0 ? askText = url.substring(askIn + 1, wellIn) : null;
	wellText = url.substring(wellIn + 1);

	//2.获取每一部分信息
	let result = {};
	wellText !== '' ? result['HASH'] = wellText : null;
	if (askText !== '') {
		let ary = askText.split('&');
		ary.forEach(item => {
			let itemAry = item.split('=');
			result[itemAry[0]] = itemAry[1];
		});
	}
	return result;
}

/* 
//基于正则封装的才是最完美的(后面学)
function queryURLParams(url) {
	let result = {},
		reg1 = /([^?=&#]+)=([^?=&#]+)/g,
		reg2 = /#([^?=&#]+)/g;
	url.replace(reg1, (n, x, y) => result[x] = y);
	url.replace(reg2, (n, x) => result['HASH'] = x);
	return result;
} 
*/

let aa = 'http://www.zhufengpeixun.cn/index.html?lx=1&name=zhufeng&teacher=aaa#box';
let paramsObj = queryURLParams(aa);
console.log(paramsObj);
```


#### 2、日期对象基础知识总结
 new Date() **获取的本台计算机的时间,不是公共时间**;
 new Date()**获取的时间是对象**
```javascript
let time = new Date();
/*
 * 获取当前客户端（本机电脑）本地的时间
 *    这个时间用户是可以自己修改的，所以不能作为重要的参考依据
 * 
 * Fri Jul 26 2019 10:02:17 GMT+0800 (中国标准时间)
 *    获取的结果不是字符串是对象数据类型的，属于日期对象(或者说是Date这个类的实例对象)
 */
typeof time;  //=>"object"
```

标准日期对象中提供了一些属性和方法，供我们操作日期信息

- getFullYear()  获取年
- getMonth()  获取月   结果是0~11代表第一月到第十二月
- getDate()  获取日 

- getDay()  获取星期   结果是0~6代表周日到周六
- getHours() 获取时   
- getMinutes() 获取分
- getSeconds() 获取秒
- getMilliseconds() 获取毫秒
- getTime() 获取当前日期距离1970/1/1 00:00:00 这个日期之间的毫秒差
- toLocaleDateString()  获取年月日（字符串）
- toLocaleString()  获取完整的日期字符串      

#### 3、日期对象的小时钟案例(还有一个有趣的CSS渐变色)
1. **要记住定时器里面放的是函数!不用加括号,加了括号就自执行了,就变成函数return的结果了**
2. **获得的月数是获取月   结果是0~11代表第一月到第十二月**
3. **获取星期   结果是0~6代表周日到周六**
```html
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>小时钟</title>
	<!-- IMPORT CSS -->
	<style>
		* {
			margin: 0;
			padding: 0;
		}
		#clockBox {
			position: absolute;
			right: 0;
			top: 0;
			padding: 0 15px;
			line-height: 70px;
			font-size: 24px;
			color: darkred;
			/* 设置背景渐变色 */
			background: lightblue;
			background: -webkit-linear-gradient(top left, lightblue, lightcoral, lightcyan);
		}
	</style>
</head>
<body>
	<div id="clockBox">
		2019年07月26日 星期五 10:25:03
	</div>
	<!-- IMPORT JS -->
	<script>
		let clockBox = document.getElementById('clockBox');
		/* 
		 * addZero:不足十补充零
		 *   @params
		 *      val需要处理的值
		 *   @return
		 		处理后的结果（不足十位的补充零）
		 * by Team on 2019/07/26
		 */
		function addZero(val) {
			val = Number(val);
			return val < 10 ? '0' + val : val;
		}
        
		/* 
		 * queryDate:获取当前的日期，把其转换为想要的格式
		 *   @params
		 *   @return
		 * by Team on 2019/07/26
		 */
		function queryDate() {
			// 1.获取当前日期及详细信息
			let time = new Date(),
				year = time.getFullYear(),
				month = time.getMonth() + 1,
				day = time.getDate(),
				week = time.getDay(),
				hours = time.getHours(),
				minutes = time.getMinutes(),
				seconds = time.getSeconds();
			let weekAry = ['日', '一', '二', '三', '四', '五', '六'];
			// 2.拼凑成我们想要的字符串
			let result = year + "年" + addZero(month) + "月" + addZero(day) + "日";
			result += " 星期" + weekAry[week] + " ";
			result += addZero(hours) + ":" + addZero(minutes) + ":" + addZero(seconds);
			// 3.把处理好的结果放到盒子中
			clockBox.innerHTML = result;
		}
		// 加载页面执行方法
		queryDate();
		// 定时器控制运动：设置一个setInterval定时器（到达指定时间干什么事情的东西就是定时器），每隔1000MS执行queryDate方法
		setInterval(queryDate, 1000);
	</script>
</body>
</html>
```



## 二十、5.8号学习总结(工作日最后一天休息)


## 二十一、5.9号学习总结


#### 1、实现一个最简陋的4位数字验证码

> 实现一个最LOW的验证码：数字+字母共四位
>
> 验证码目的：防止外挂程序恶意批量注入的

 ```html
<body>
	<input type="text" id="codeInp">
	<br>
	<span id="codeBox">AAAA</span>
	<button id="changeCode">看不清换一张</button>

	<!-- IMPORT JS -->
	<script>
		let codeInp = document.getElementById('codeInp'),
			codeBox = document.getElementById('codeBox'),
			changeCode = document.getElementById('changeCode');

		/*
		 * queryCode：获取到四位随机验证码，然后放到指定的盒子中
		 *   @params
		 *   @return
		 * by Team on 2019/07/24  
		 */
		function queryCode() {
			// 准备获取范围的字符串 0~61
			let area = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
			let result = "";
			for (let i = 0; i < 4; i++) {
				// 每一次循环都获取一个随机的数字索引
				let ran = Math.round(Math.random() * 61);
				// 再根据获取的索引从范围字符串中找到对应的字符，把找到的字符拼接到最后的结果中
				result += area.charAt(ran);
			}
			// 放到盒子里面
			codeBox.innerHTML = result;
		}

		// 第一次加载页面需要执行方法，让其显示在页面中
		queryCode();

		// 点击看不清按钮，需要重新执行方法生成新的验证码
		changeCode.onclick = queryCode;

		// 文本框失去焦点的时候：验证用户输入的内容和验证码是否相同，给予相关的提示，如果不一样需要重新生成验证码
		// onblur：文本框失去焦点事件
		codeInp.onblur = function () {
			// 获取用户和验证码内容（表单元素.value / 非标单元素.innerHTML 获取内容）
			let val = codeInp.value,
				code = codeBox.innerHTML;
			// 不区分大小写的验证（都转成小写）
			if (val.toLowerCase() === code.toLowerCase()) {
				alert('温馨提示：验证码输入成功！');
			} else {
				alert('温馨提示：验证码输入有误，请重试！');
				codeInp.value = '';
				// 重新生成验证码
				queryCode();
			}
		}
	</script>
</body>
 ```

#### 2、时间字符串格式化案例(以及封装一个时间组件(这需要以后正则学了来理解))


> new Date() 除了获取本机时间，还可以把一个时间格式字符串转换为标准的时间格式

```javascript
new Date("2019/7/26");
//=>Fri Jul 26 2019 00:00:00 GMT+0800 (中国标准时间)

/*
 * 支持的格式
 *    yyyy/mm/dd
 *    yyyy/mm/dd hh:mm:ss
 *    yyyy-mm-dd 这种格式在IE下不支持
 */
```

**时间字符串格式化案例**

> 字符串处理解决办法

```javascript
// =>不足十位补充零
let addZero = val => {
	val = Number(val);
	return val < 10 ? '0' + val : val;
};

/*
* 字符串处理解决办法
*/
function formatTime(time) {
    // 1.先获取年月日等信息
    let ary = time.split(' '),
    	aryLeft = ary[0].split('-'),
    	aryRight = ary[1].split(':');
    ary = aryLeft.concat(aryRight);
    // 2.拼接成为我们想用的格式
    let result = ary[0] + "年" + addZero(ary[1]) + "月" + addZero(ary[2]) + "日";
    result += " " + addZero(ary[3]) + ":" + addZero(ary[4]) + ":" + addZero(ary[5]);
    return result;
}
let time = '2019-5-30 12:0:0'; 
time = formatTime(time);
console.log(time);
// =>"2019年05月30日 12:00:00"
```

> 基于日期对象处理

```javascript
/*
 * 基于日期对象处理 
 */
function formatTime(time) {
    // 1.把时间字符串变为标准日期对象
    time = time.replace(/-/g, '/');
    time = new Date(time);
    // 2.基于方法获取年月日等信息
    let year = time.getFullYear(),
        month = addZero(time.getMonth() + 1),
        day = addZero(time.getDate()),
        hours = addZero(time.getHours()),
        minutes = addZero(time.getMinutes()),
        seconds = addZero(time.getSeconds());
    // 3.返回想要的结果
    return year + "年" + month + "月" + day + "日 " + hours + ":" + minutes + ":" + seconds;
}
let time = '2019-5-30 12:0:0';
time = formatTime(time);
console.log(time);
// =>"2019年05月30日 12:00:00"
```

> 封装一套公共的时间字符串格式化处理的方式 

```javascript
/*
 * 封装一套公共的时间字符串格式化处理的方式 
 */
String.prototype.formatTime = function formatTime(template) {
    // 初始化模板
    typeof template === 'undefined' ? template = "{0}年{1}月{2}日 {3}:{4}:{5}" : null;
    // this:我们要处理的字符串
    // 获取日期字符串中的数字信息
    let matchAry = this.match(/\d+/g);
    // 模板和数据的渲染（引擎机制）
    template = template.replace(/\{(\d+)\}/g, (x, y) => {
    	let val = matchAry[y] || '00';
    	val.length < 2 ? val = '0' + val : null;
    	return val;
	});
	return template;
};
let time = '2019-5-30 12:0:0';
console.log(time.formatTime("{1}-{2} {3}:{4}"));
// =>"2019年05月30日 12:00:00"
```

#### 3、DOM及其基础操作

> DOM：document object model 文档对象模型，提供一些属性和方法供我们操作页面中的元素

**获取DOM元素的方法**

- document.getElementById()  指定在文档中，基于元素的ID或者这个元素对象  ==>ID这种的
- [context].getElementsByTagName()  在指定上下文(容器)中，通过标签名获取一组元素集合 ==>DIV这种的

- [context].getElementsByClassName()  在指定上下文中，通过样式类名获取一组元素集合 （不兼容IE6~8） ==>class这种的
- document.getElementsByName()  在整个文档中，通过标签的NAME属性值获取一组节点集合(<input type="radio" name="sex" value="男" checked>) （在IE中只有表单元素的NAME才能识别，所以我们一般只应用于表单元素的处理）
- document.head / document.body / document.documentElement 获取页面中的 HEAD/BODY/HTML 三个元素
- [context].querySelector([selector])  在指定上下文中，通过选择器获取到指定的元素对象
- [context].querySelectorAll([selector])  在指定上下文中，通过选择器获取到指定的元素集合

```javascript
//=> querySelector / querySelectorAll 不兼容IE6~8
let box = document.querySelector('#box');
let links = box.querySelectorAll('a');
// links=document.querySelectorAll('#box a');
let aas=document.querySelectorAll('.aa');
 let navList = document.querySelectorAll('.tab li');       //tab下所有的li
 let divList = document.querySelectorAll('.tabBox>div');     //tabBox下的亲儿子div  孙子的不算
```

#### 4、节点与节点之间的关系

**JS中的节点和描述节点之间关系的属性**

> 节点 ： Node （页面中所有的东西都是节点）
>
> 节点集合：NodeList  （getElementsByName / querySelectorAll 获取的都是节点集合）

- 元素节点 （元素标签）
  + nodeType：1
  + nodeName : 大写的标签名
  + nodeValue ：null
- 文本节点
  - nodeType：3
  - nodeName : '#text'
  - nodeValue ：文本内容
- 注释节点
  - nodeType：8
  - nodeName : '#commen'
  - nodeValue ：注释内容
- 文档节点 document
  - nodeType：9
  - nodeName : '#document'
  - nodeValue ：null
- ......

描述这些节点之家关系的属性

- childNodes ：获取所有的子节点(文字,隔行,div全部获取)   标准浏览器（非IE6~8）中会把空格和换行当做文本节点处理 （childNodes包含所有节点）
- children：获取所有的元素子节点（子元素标签集合） ==>只获取div li span 类似的这种标签
- parentNode：获取父亲节点
- firstChild：获取第一个子节点
- lastChild：获取最后一个子节点
- firstElementChild / lastElementChild ：获取第一个和最后一个元素子节点 （不兼容IE6~8）
- previousSibling：获取上一个哥哥节点
- nextSibling：获取下一个弟弟节点
- previousElementSibling / nextElementSibling ：获取哥哥和弟弟元素节点（不兼容IE6~8）
- ......

#### 5、在JS中动态增删改元素

`createElement 创建元素对象` 

`createTextNode 创建文本对象`

`appendChild 把元素添加到容器的末尾`

`insertBefore 把元素添加到指定容器中指定元素的前面`

`removeChild 移除容器中的某个元素`
```javascript
// 动态创建一个DIV元素对象，把其赋给BOX
let box = document.createElement('div');
box.id = 'boxActive';
box.style.width = '200px';
box.style.height = '200px';
box.className = 'RED';

// 动态创建一个文本
let text = document.createTextNode('珠峰培训');

// 添加：容器.appendChild(元素)
box.appendChild(text);
// document.body.appendChild(box);

// 放到指定元素前：容器.insertBefore([新增元素],[指定元素])
let haha = document.getElementById('haha');
// haha.parentNode.insertBefore(...)
document.body.insertBefore(box, haha);
```

#### 6、克隆节点

`cloneNode(true/false) 克隆元素或者节点`

`removeChild 移除容器中的某个元素`

```html
<div class="box">
    <span>珠峰培训1</span>
</div>
<script>
    let box1 = document.querySelector('.box');
    // 克隆第一份（深克隆）
    let box2 = box1.cloneNode(true);
    box2.querySelector('span').innerText = '珠峰培训2';
    // 克隆第二份（浅克隆）
    let box3 = box1.cloneNode(false);
    box3.innerHTML = "<span>珠峰培训3</span>";

    document.body.appendChild(box2);
    document.body.appendChild(box3);

    //===========
    // 容器.removeChild(元素)
    document.body.removeChild(box2);
</script>
```

#### 7、自定义属性的在节点中设置的方法
`setAttribute / getAttribute / removeAttribute 设置获取移除元素的自定义属性信息（这种方式是把自定义属性放到元素结构上）`

```javascript
var btnList = document.querySelectorAll('button');
for (var i = 0; i < btnList.length; i++) {
	// 设置自定义属性：元素对象.属性名=属性值（原理是向元素对象对应的堆内存中添加了一个属性）
	// btnList[i].myIndex = i;

	// 设置自定义属性：基于SET-ATTRIBUTE是把属性信息写到了元素标签的结构上（在结构中可以看到的），并没有放到元素对象对应的堆内存中
	btnList[i].setAttribute('data-index', i);
	btnList[i].onclick = function () {
		// 获取自定义属性：元素对象.属性名 （原理是从堆内存中获取到对应的属性值）
		// alert(this.myIndex);

		// 基于GET-ATTRIBUTE可以把结构上存储的自定义属性值获取
		alert(this.getAttribute('data-index'));
	}
}
```

#### 8、git的基础操作
GIT工作原理

- 工作区：我们能看到的，并且用来写代码的区域
- 暂存区：临时存储用的
- 历史区：生成历史版本

工作区 -> 暂存区 -> 历史区



**1.GIT的全局配置**

> 第一次安装完成git后，我们在全局环境下配置基本信息：我是谁？

```shell
$ git config -l  查看配置信息
$ git config --global -l  查看全局配置信息

配置全局信息：用户名和邮箱
$ git config --global user.name 'xxx'
$ git config --global user.email 'xxx@xx.xx'
```

**2.创建仓库完成版本控制**

> 创建本地git仓库

```shell
$ git init 
//=>会生成一个隐藏文件夹 “.git”（这个文件夹千万不要删，因为暂存区和历史区还有一些其它的信息都在这里，删了就不是一个完整的git仓库）
```

> 在本地编写完成代码后（在工作区），把一些文件提交到暂存区

```shell
$ git add xxx  把某一个文件或者文件夹提交到暂存区
$ git add .  把当前仓库中所有最新修改的文件都提交到暂存区
$ git add -A
 
$ git status 查看当前文件的状态（红色代表在工作区，绿色代表在暂存区，看不见东西证明所有修改的信息都已经提交到历史区）
```

> 把暂存区内容提交到历史区

```shell
$ git commit -m'描述信息：本次提交内容的一个描述'

查看历史版本信息（历史记录）
$ git log
$ git reflog  包含回滚的信息
```

#### 9、Git与GitHub仓库连接
1. Settings 用户设置
   - Profile   修改自己的基本信息
   - Account  可以修改用户名
   - Security  可以修改自己的密码
   - Emails 邮箱（必须进行邮箱校验）
   - ......

2. 创建仓库

   new repository  ->  填写信息 -> Create  repository 

   - public  公共仓库作为开源的项目
   - private 私有仓库作为内部团队协作管理的项目

   Settings -> 删除仓库Delete this repository

   ​                ->Collaborators 设置协作开发的人员 

   Code 可以查看历史版本信息和分支信息

   

3. 把本地仓库信息提交到远程仓库

   ```shell
   //=>建立本地仓库和远程仓库的链接
   查看本地仓库和哪些远程仓库保持链接
   $ git remote -v
   让本地仓库和远程仓库新建一个链接 origin是随便起的一个链接名（可以改成自己想要的，只不过一般都用这个名字）
   $ git remote add origin [GIT远程仓库地址]
   删除关联信息
   $ git remote rm origin
   ```

   ```shell
   提交之前最好先拉取
   这个origin的名字要和上面那个origin名字一样
   $ git pull origin master
   把本地代码提交到远程仓库（需要输入github的用户名密码）
   $ git push origin master
   ```

   ```shell
   $ git clone [远程仓库git地址] [别名：可以不设置，默认是仓库名]
   /*
    * 真实项目开发流程：
    *   1.组长或者负责人先创建中央仓库(增加协作者)
    *   2.小组成员基于 $ git clone 把远程仓库及默认的内容克隆到本地一分（解决了三个事情：初始化一个本地仓库“git init”、和对应的远程仓库也保持了关联“git remote add”、把远程仓库默认内容拉取到本地“git pull”）
    *   3.每个组员写完自己的程序后，基于“git add/git commit”把自己修改的内容存放到历史区，然后通过“git pull/git push”把本地信息和远程仓库信息保持同步即可（可能涉及冲突的处理）
    */
   ```

## 二十二、5.10号学习总结


#### 1、npm与公司项目工作流程

    NPM

   > node package manger ：NODE模块管理工具，根据NPM我们可快速安装、卸载所需要的资源文件（例如：jQuery、vue、vue-router...）
   >
   >  
   >
   > 去NODE官网：https://nodejs.org/zh-cn/  下载NODE（长期支持版），安装NODE后，NPM也就跟着安装了
   >
   > $ node  -v
   >
   > $ npm   -v    出现版本号证明安装成功

    基于npm进行模块管理

   > https://www.npmjs.com/   基于npm是从npmjs.com平台上下载安装


   ```shell
   $ npm install xxx  把模块安装在当前项目中（node_modules）
   $ npm install xxx -g  把模块安装在全局环境中
   $ npm i xxx@1.0.0  安装指定版本号的模块
   $ npm view xxx versions > xxx.version.json  查看某个模块的版本信息（输出到指定JSON文件中）
   
   /*
    * 什么情况下会把模块安装在全局？
    *   ->可以使用“命令”对任何的项目进行操作
    *   ->$ npm root -g 查看全局安装的目录
    *   ->因为在安装目录下生成了 xxx.cmd 的文件，所以我们能够使用 xxx 的命令进行操作
    *
    * 安装在本地项目中的模块
    *   ->可以在项目中导入进来使用
    *   ->但是默认不能基于命令来操作（因为没有.cmd文件）
    *   ->但是可以基于package.json中的scripts，配置一些npm可以执行命令，配置后通过$ npm run xxx执行
    */
   这里以Less为例子 假如less安装在全局下,我们就可以打开cmd输入'lessc xx.less xx.min.css -x' (就是把1个less转换成css)
   但是假如不是全局安装我们就需要在package.json中的scripts中配置一些npm可以执行命令,例如
   ```
   ![](学习总结图片/5.10/1620644724(1).jpg)
   ```shell
   $ npm init -y  初始化当前项目的配置依赖清单（项目文件加的名字中不能出现中文、大写字母和特殊符号）
   	=>创建成功后在当前项目中生成 package.json 的清单文件
   	dependencies ：生产依赖模块（开发和项目部署的时候都需要）
   	devDependencies ：开发依赖模块（只有开发的时候需要）
       scripts : 配置本地可执行命令的
       
   $ npm i xxx --save   把模块保存在清单生产依赖中
   $ npm i xxx --save-dev  把模块保存在清单开发依赖中
   $ npm install  跑环境，按照清单安装所需的模块
   
   $ npm uninstall xxx
   $ npm uninstall xxx -g 卸载安装过的模块
   ```

window操作系统：在某个文件夹下执行DOS命令

​    1. windows + r  -> 运行窗口中输入cmd 

​         -> 磁盘符:    进入到指定磁盘 

​         -> cd xxx     进入到指定的目录

​         -> cd 直接拖进想要进入的目录文件件    直接进入

​       （MAC的终端就是这样操作的）

​    2. 在文件夹地址栏直接输入cmd即可

​    3. 在文件夹中 “shift + 鼠标右键” -> 在此处打开命令窗口

如果想查看当前目录中的文件内容

​    MAC： ls  / ls -A

​    WIN：dir 

--------------------



一个新项目的开始：

1. 创建项目文件夹

2. 把他作为一个新的仓库进行代码管理（可以基于$git clone把远程仓库克隆下来即可）

3. 初始化模块配置清单package.json：$npm init -y

4. 安装所需要的模块：$npm i jquery bootstrap@3 less ....

5. 正常开发

6. 开发中：可能需要在本地配置命令去完成一些功能（例如LESS文件编译，此时需要配置npm可执行的命令）

   ```json
   "scripts": {
       "zxt": "lessc css/index.less css/index.min.css -x",
       "xxx": "webpack"
   },
   ```

​     需要编译的时候，执行 $ npm run zxt

​     ....

7. 开发中我们需要基于git把文件进行管理：生成对应的历史版本

   提交到暂存区、历史区、远程仓库的时候，项目中很多文件是无需处理和提交的，例如：node_modules、.idea...，不需要提交的，我们生成一个.gitignore忽略文件

   ```js
   #dependencies
   node_modules
   ....
   ```

8. 由于每次git提交的时候，我们都不去提交node_modules，所以团队协作开发中，我们每当拉下来程序后，都需要“跑环境”：执行 $ npm install ，按照项目中的package.json中的依赖项信息，把缺失的模块都安装一遍


#### 2、npm与yarn与淘宝镜像

yarn   安装与使用
![](学习总结图片/5.10/1620648411(1).jpg)


淘宝镜像 安装与使用

![](学习总结图片/5.10/1620648467(1).jpg)

#### 3、let/const和var的区别

`1.let和const不存在变量提升机制`

> 创建变量的六种方式中：var/function有变量提升，而let/const/class/import都不存在这个机制

`2.var允许重复声明，而let是不允许的`

> 在相同的作用域中（或执行上下文中）
>
> - 如果使用var/function关键词声明变量并且重复声明，是不会有影响的（声明第一次之后，之后再遇到就不再重复声明了）
> - 但是使用let/const就不行，浏览器会校验当前作用域中是否已经存在这个变量了，如果已经存在了，则再次基于let等重新声明就会报错

```javascript
//=>在浏览器开辟栈内存供代码自上而下执行之前，不仅有变量提升的操作，还有很多其它的操作=>“词法解析”或者“词法检测”：就是检测当前即将要执行的代码是否会出现“语法错误 SyntaxError”，如果出现错误，代码将不会再执行（第一行都不会执行）
console.log(1); //=>这行代码就已经不会再被执行了
let a = 12;
console.log(a);
let a = 13;  //=>Uncaught SyntaxError: Identifier 'a' has already been declared
console.log(a);
```

```javascript
//=>所谓重复是：不管之前通过什么办法，只要当前栈内存中存在了这个变量，我们使用let/const等重复再声明这个变量就是语法错误
console.log(a);
var a = 12;
let a = 13; //=>Uncaught SyntaxError: Identifier 'a' has already been declared
console.log(a);
```
#### 4、变量提升(不用太纠结,因为现在都用let)

> 当浏览器开辟出供代码执行的栈内存后，代码并没有自上而下立即执行，而是继续做了一些事情：**把当前作用域中所有带var/function关键字的进行提前的声明和定义  =>变量提升机制**
>
> - 带var的只是提前声明（declare） “var  a;”  如果只声明没有赋值，默认值是undefined
> - 带function的不仅声明，而且还定义了（defined）  “a=13”定义其实就是赋值，准确来说就是让变量和某个值进行关联
> - 只有含有var 的变量才会提升 a = 12;这种是不会提升的
> - 带var 又带function的是只提升var函数是不会提升的 例如 var a = function(){
    return 1+1;
}    这种情况只提升var a
> - 不管var 在哪里  在函数还是条件里面  只要有var  就要进行变量提升
![](学习总结图片/5.10/变量提升.png)

带var和不带var的区别**
**let，const 声明的变量不会绑定给window对象 而var会**
```javascript
//=>在全局作用域下的区别
/*
 * 不带var的：相当于给全局对象window设置了一个属性a
 *    window.a = 13;
 */
a = 13;
console.log(a); //=>window.a

/*
 * 栈内存变量存储空间
 *    b
 * 带var的：是在全局作用域下声明了一个变量b（全局变量），但是在全局下声明的变量也同样相当于给window增加了一个对应的属性（只有全局作用域具备这个特点） 如果在函数作用域或者对象作用域里面也是一样的 值有没有不确定,但是window.a 是一定设置了
 */
var b = 14; //=>创建变量b & 给window设置了属性b
console.log(b); //=>14
console.log(window.b); //=>14
```
/*
 * 全局作用域
 *   1.变量提升  
 *     但是做函数的有特殊性：在老版本浏览器中，确实不论条件是否成立，函数也是提前声明或者定义的，但是新版本浏览器中，为了兼容ES6严谨的语法规范，条件中的函数在变量提升阶段只能提前声明，不能提前定义
 *     function fn;
 *   2.代码执行
 */
// console.log(fn); //=>undefined
// // fn(); //=>Uncaught TypeError: fn is not a function
// if ('fn' in window) { //=>TRUE
// 	// 条件成立，进来后的第一件事是给FN赋值，然后在代码执行
// 	fn(); //=>"哈哈哈"
// 	function fn() {
// 		console.log('哈哈哈');
// 	}
// }
// fn(); //=>"哈哈哈"

#### 5、关于xxx in obj

/* let obj = {
	name: '吴振宇',
	age: 21,
	GF: null
};
console.log("name" in obj); //=>TRUE  
console.log("GF" in obj); //=>TRUE  
console.log("BF" in obj); //=>FALSE
// [PROPERTY] in [OBJECT] 验证当前属性是否属于这个对象   hasOwnProperty(后面学)*/


#### 6、暂时性死区

// console.log(a); //=>Uncaught ReferenceError: a is not defined
// console.log(typeof a); //=>"undefined"  这是浏览器的BUG，本应该是报错的，因为没有a（暂时性死区）

**let不会出现这种情况**
console.log(typeof a); //=>Uncaught ReferenceError: Cannot access 'a' before initialization
let a;

#### 7、私有栈内存处理

传参传进去的参数 在函数执行的时候会先赋值这一步骤是在代码执行前的 
如果传的值是一个值对象,就把存对象的堆内存地址传进去 例如图三

![](学习总结图片/5.10/私有作用域下的变量提升1.png)
```javascript
console.log(a, b);
var a = 12,
	b = 12;

function fn() {
	console.log(a, b);
	var a = b = 13;
	console.log(a, b);
}
fn();
console.log(a, b); 
```

![](学习总结图片/5.10/私有作用域下的变量提升2.png)



**注意看这里 b=fn(10)  执行了且把b赋值了,结果是函数返回值赋值给了b    这个函数没有返回值,所以是undefined**

```javascript
console.log(a, b, c);
var a = 12,
	b = 13,
	c = 14;
//函数里面的形参赋值在变量提升后,代码执行前
function fn(a) {
	console.log(a, b, c);
	a = 100;
	c = 200;
	console.log(a, b, c);
}
b = fn(10);
console.log(a, b, c); 
```

作用域关于函数带有参数的情况
![](学习总结图片/5.11/私有作用域下的变量提升3.png)

## 二十三、5.11学习总结

#### 1、作用域链的查找机制
函数在哪里创建,函数的作用域就已经确定了
函数的上级作用域只和函**数创建的位置有关**,和函数执行的位置无关
![](学习总结图片/5.11/作用域链的查找机制.png)

#### 2、闭包作用域(闭包是重点)

1. 创建函数
   - 开辟一个堆内存
   - 把函数体中的代码当做字符串存储进去
   - 把堆内存的地址赋值给函数名/变量名
   - **函数在哪创建，那么它执行时候所需要查找的上级作用域就是谁**

2. 函数执行
   - 形成一个全新的(私有作用域、执行上下文、私有栈内存)(这3种叫法意思是一样的)（执行一次形成一个，多个之间也不会产生影响）
   - 形参赋值 & 变量提升
   - 代码执行（把所属堆内存中的代码字符串拿出来一行行执行）
   - **遇到一个变量，首先看它是否为私有变量（形参和在私有作用域中声明的变量是私有变量），是私有的就操作自己的变量即可，不是私有的则向上级作用域中查找...一直找到全局作用域为止  =>作用域链查找机制**
   - 私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了，这种机制其实就是**闭包的保护机制**

3. 关于堆栈内存释放问题（以谷歌webkit内核为例子）

   > 函数执行就会形成栈内存（从内存中分配的一块空间），如果内存都不销毁释放，很容易就会导致栈内存溢出（内存爆满，电脑就卡死了），堆栈内存的释放问题是学习JS的核心知识之一

   - 堆内存释放问题

    ```javascript
   //=>创建一个引用类型值，就会产生一个堆内存
   //如果当前创建的堆内存不被其它东西所占用了（浏览器会在空闲的时候，查找每一个内存的引用状况，不被占用的都会给回收释放掉），则会释放
   let obj = {
       name : 'zhufeng'
   };
   let oop = obj;
   //此时obj和oop都占用着对象的堆内存，想要释放堆内存，需要手动解除变量和值的关联（null：空对象指针）
   obj = null;
   oop = null;
    ```

   - 栈内存释放

     ```javascript
     //=>打开浏览器形成的全局作用域是栈内存
     //=>手动执行函数形成的私有作用域是栈内存
     //=>基于ES6中的let/const形成的块作用域也是栈内存
     //=>....
     
     /*
      * 全局栈内存：关掉页面的时候才会销毁
      * 私有栈内存：
      *    1.一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁释放掉（排除出现无限极递归、出现死循环的模式）
      *    2.但是一旦栈内存中的某个东西（一般都是堆地址）被私有作用域以外的事物给占用了，则当前私有栈内存不能立即被释放销毁（特点：私有作用域中的私有变量等信息也保留下来了）  =>市面上认为的闭包：函数执行形成不能被释放的私有栈内存，这样的才是闭包
      */
     function fn(){
         //...
     }
     fn(); //=>函数执行形成栈内存，执行完成栈内存销毁
     
     function X(){
         return function(){
             //...
         }
     }
     let f=X(); //=>f占用了X执行形成的栈内存中的一个东西（返回小函数对应的堆），则X执行形成的栈内存不能被释放了
     ```

**这张图 好好理解 ,建议反复观看**
每次执行代码都要创建一个全新的自己的私有占内存
![](学习总结图片/5.11/堆栈内存释放案例.png)



## 二十四、5.12学习总结

加班到脑溢血,不过又一个老是出现的问题希望今天就能记住

#### 1、class动态绑定

:class="{'active':isActive==-1}" 

第一种（用逗号隔开）
:class="{ 'active': isActive, 'sort': isSort }"
第二种（放在data里面）
//也可以把后面绑定的对象写在一个变量放在data里面，可以变成下面这样
:class="classObject"
data() {
  return {
    classObject:{ active: true, sort:false }
  }
}
第三种（使用computed属性）
:class="classObject"
data() {
  return {
    isActive: true,
    isSort: false
  }
},
computed: {
  classObject: function () {
    return {
      active: this.isActive,
      sort:this.isSort
    }
  }

## 二十五、5.13学习总结


#### 1、关于if 和 for中的let和var

在if内用var声明变量，虽然if后面是块级作用域，**但是var声明的变量不支持块级作用域**，
该变量会向上冒泡到支持的作用域范围，也就是函数作用域和全局作用域
console.log(haha);=>undefined
if(true){
    console.log(haha);=>undefined
    var haha = '10'
    console.log(haha);=>10
}
console.log(haha);=>10
在for循环内用var声明变量，该变量也是全局的
console.log(i); // 输出为undefined
for (var i=0;i<5;i++) {
	console.log('内部获取的'+i);
}
console.log('外部获取'+i); // 输出5
let有块级作用域所以变量是局部的

#### 2、闭包的2作用已经Jquery库中运用闭包的例子

> 从性能角度讲，我们真实项目中应该减少对闭包的使用（因为闭包会产生不释放的栈内存，过多使用容易导致内存溢出或者降低性能）

- 保护
- 保存

1. jQuery（JQ）前端非常经典的类库：提供了大量的方法供开发人员使用

   =>为了防止全局变量污染（解释：导入JQ后，它里面有大量的方法，如果这些方法不保护起来，用户编写的方法很容易和JQ方法名字相同产生冲突，产生冲突可以理解为全局变量污染）,JQ中的方法和变量需要用闭包保护起来
**window.jQuery = window.$ = jQuery;** 通过给全局对象增加属性:jQuery和$，把私有的jQuery方法暴露到全局作用域下，
供外面使用（等价于return jQuery）（外界需要使用函数中的私有内容，我们可以基于window.xxx和return xxx两种方式实现这个需求） 
   ```javascript
   /*==JQ源码剖析==*/
   (function(global, factory){
       //...
       //typeof window!=="undefined"?window:this 验证当前所处环境的全局对象是window还是global等
       //factory=>function zhufeng(window,noGlobal){}
   	factory(global); //=>zhufeng(window)
   })(window,function zhufeng(window,noGlobal){
       //...
       var jQuery=function(selector, context){
           //...
       };
       
    	//=>通过给全局对象增加属性:jQuery和$，把私有的jQuery方法暴露到全局作用域下，供外面使用（等价于return jQuery）（外界需要使用函数中的私有内容，我们可以基于window.xxx和return xxx两种方式实现这个需求）   
       window.jQuery = window.$ = jQuery;
   });
   
   //=>开始使用JQ
   jQuery(); //=>window.jQuery()
   $();
   ```

   在真实项目中，我们一般都要把自己写的内容放到一个闭包中，这样可以有效防止自己的代码和别人代码产生冲突（全局变量污染：真实项目中是要尽可能减少对全局变量的使用的）；如果需要把自己的东西给别人用，基于return和window.xxx等方式暴露给别人即可

   ```javascript
   //=>原生JS
   var zhufeng=(function(){
     //....A自己写的代码  
     return {
        name:'xxx'
     };
   })();
   
   (function(){
     //....B自己写的代码  
     window.xxx=xxx;
   })();
   
   //=>JQ
   $(function(){
      //...这样写在某些角度上也是为了减少全局变量
   });
   
   .....
   ```

#### 3、let/const/class的块级作用域

基于LET/CONST/CLASS等创建变量，会把所在的大括号（除对象的大括号之外）当做一个全新的私有块级作用域

   - 函数执行会产生私有的栈内存（作用域/执行上下文）
   - let等也会产生私有的块作用域（var不会）

   ```javascript
   if(1===1){
   	var a=10;
   }
   console.log(a); //=>10  a是全局作用域
   ```

   ```javascript
   if(1===1){
       //=>let会有块作用域（现在大括号就是一个私有作用域）
       //=>a是私有变量
   	let a=10;
   }
   console.log(a);//=>Uncaught ReferenceError: a is not defined
   ```


#### 4、关于This指向问题的部分



> 函数执行的主体（不是上下文）: 意思是谁把函数执行的，那么执行主体就是谁
>
> THIS非常的不好理解，以后遇到THIS，想一句话：“你以为你以为的就是你以为的”

1. **给元素的某个事件绑定方法，当事件触发方法执行的时候，方法中的this是当前操作的元素本身**

2. 如何确定执行主体(this)是谁？**当方法执行时候，我们看方法前面是否有点，没有点this是window或undefined；有点，点前面是谁this就是谁**; 

```javascript
var name='珠峰培训';
function fn(){
    console.log(this.name);
}
var obj={
    name:"你好世界",
    fn:fn
};
obj.fn(); //=>this:obj
fn(); //=>this:window（非严格模式，严格模式下是undefined） window.fn()把window.省略了

(function(){
	//自执行函数中的this是window或undefined    
})();
```

思考？

```javascript
//=>hasOwnProperty方法中的this：ary.__proto__.__proto__
ary.__proto__.__proto__.hasOwnProperty()

let obj={
    fn:(function(n){
       //把自执行函数执行的返回结果赋值给fn
       //this:window
       return function(){
           //=>fn等于这个返回的小函数
           //this:obj
       };
    })(10)
};
obj.fn();


function fn(){
    //this:window
    console.log(this);
}
document.body.onclick=function(){
    //this:document.body
    fn();
}
```

#### 5、重温选项卡加图解

```javascript
	// 循环给每一个LI绑定点击事件
		for (var i = 0; i < navList.length; i++) {
			navList[i].onclick = function () {
				//i:循环结束后的结果
				changeTab(i);
			}
		} 
```
这样是不行,因为等函数执行的时候找的是全局的i i已经等于循环结束后的i了
![](学习总结图片/5.13/重温选项卡1.png)

运用闭包 这2个方法都可以  第一种看起来好理解一点
```javascript
		/*
		 * 利用闭包解决
		 *   1.闭包可以保存信息（栈内存不销毁即可）,此处我们保存后续需要的索引信息即可
		 *   2.执行事件绑定的小函数，遇到i，不让他往全局找，找我们闭包中存储的索引即可（闭包是小函数的上级作用域，也就是小函数是在闭包中创建的） 
		 */
		for (var i = 0; i < navList.length; i++) {
			~ function (n) {
				navList[n].onclick = function () {
					changeTab(n);
				}
			}(i);
		} 
		 for (var i = 0; i < navList.length; i++) {
			navList[i].onclick = (function (n) {
				return function () {
					changeTab(n);
				}
			})(i);
		} 

```
![](学习总结图片/5.13/重温选项卡2.png)

运用Let
```javascript
	for (let i = 0; i < navList.length; i++) {
			navList[i].onclick = function () {
				changeTab(i);
			}
		}
```
![](学习总结图片/5.13/重温选项卡3.png)

性能最好的自定义属性

 for (var i = 0; i < navList.length; i++) {
			var item = navList[i];
			item.myIndex = i;
			item.onclick = function () {
				// this:当前点击的那个li啊
				changeTab(this.myIndex);
			}
		} 
