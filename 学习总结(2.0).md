# 努力有时候真的无法胜过天赋,但努力能让有天赋的人看得起你

> 在到达终点前,别想着安逸享乐

> 每天还是需要花半小时回顾自己一天的收货,且还得开始回顾自己的笔记 每周日必须再看一次所有的笔记

## 一、4.13 学习总结

> 曼巴

- 科比
- 布莱恩特

### 1、Vue.use 原理

![](图片(2.0)/微信截图_20220413204547.png)

### 2、源码中_vnode 和 vnode 区别


![](图片(2.0)/微信截图_20220413192511.png)

### 3、Vue自定义指令的实战之鼠标点击显示隐藏

附带的小知识

1. el.contains可以查看节点是否在这个节点上

```JavaScript
<template>
  <div v-click-outside="handleBlur" style="display:inline-flex;flex-direction:column">
    <input type="text" @focus="handleFocus" />
    <div class="box" v-show="isShow">面板</div>
  </div>
</template>
<script>
export default {
  data() {
    return { isShow: false }
  },
  directives: {
    clickOutside: {
      bind(el, dirs, vnode) { //自带的属性,里面可以拿到一些属性
        const handler = (e) => {
          if (!el.contains(e.target)) {//el.contains可以查看节点是否在这个节点上
            vnode.context[dirs.expression](e)
          }
        }
        el.handler = handler
        document.addEventListener('click', handler)
      },
      unbind(el){
          document.removeEventListener('click', el.handler)
      }
    }
  },
  methods: {
    handleFocus() {
      this.isShow = true
    },
    handleBlur() {
      this.isShow = false
    }
  }
}
</script>
<style scoped lang="scss">
.box {
  width: 150px;
  height: 100px;
  border: 1px solid red;
}
</style>
```

## 二、4.14学习总结

### 1、类的this问题
![](图片(2.0)/微信截图_20220414190515.png)
![](图片(2.0)/微信截图_20220414190622.png)


### 2、图片懒加载
>  我们需要拿到父节点但是有可能为空,解决方法nexttick或者把指令的bind改成insert
>  passive 就是一个优化类似
1. new Image 
![](图片(2.0)/微信截图_20220415134152.png)
2. 代码

```JavaScript
let VueLazyload = {
    install(Vue, userOptions) { // 声名一个指令 ，初始化懒加载功能
        let LazyClass = lazy(Vue); // koa express  插件时一个函数，返回对应的功能，为了方便传递参数
        let instance = new LazyClass(userOptions)
        Vue.directive('lazy', {
            bind: instance.add.bind(instance),
            unbind: instance.unbind.bind(instance)
        })
    }
}
// 解决this问题 常见就是bind 或者箭头函数
function getScrollParent(el) {
    let parent = el.parentNode;
    while (parent) {
        if (/(scroll)|(auto)/.test(getComputedStyle(parent)['overflow'])) {
            return parent;
        }
        parent = parent.parentNode;
    }
    return parent;
}
function lazy(Vue) { // 注入变量  es6中类的原型方法如果单独拿出来使用，他会指向undefined
    function render(imgListener,status){
        let el = imgListener.el; // 获取图片
        switch (status) {
            case 'loading': // 根据状态添加对应的图片
                el.src = imgListener.options.loading
                break;
            case 'loaded':
                el.src = imgListener.src;
                break;
            case 'error':
                el.src = imgListener.options.error;
                break;
            default:
                break;
        }
    }
    function loadImg(src){
        return new Promise((resolve,reject)=>{
            let img = new Image();
            img.src = src;
            img.onload = resolve;
            img.onerror = reject;
        })
    }
// 我希望给每个图片都增加一个实例，放到一个队列中，页面滚动时我可以去队列里查找加载哪些图片
    class ReactiveListener{
        constructor(el,src,options){
            this.el = el;
            this.src = src;
            this.options=  options;
            this.state = {loading:false}; // 用于判断图片的加载状态 , 是否加载过
        }
        checkInView(){ //检测我在不在页面中
            let {top} = this.el.getBoundingClientRect(); // 每次滚动获取的top都不一样 
            // 判断浏览的内高 和 我们图片距离顶部的高度，如果需要加载
            return top  <  window.innerHeight * this.options.preLoad
        }
        load(){ // 如果在页面中需要加载
            // 加载图片
            render(this,'loading');
            loadImg(this.src).then(()=>{
                this.state.loading = true; // 表示图片已经加载完毕了
                render(this,'loaded');
            }).catch(()=>{
                this.state.loading = true;
                render(this,'error');
            })
        } 
    }
    return class LazyClass {
        constructor(userOptions) {
            this.options = userOptions; // 为了方便获取用户传递的参数
            this.hasScrollHandler = false;
            this.queue = [];
        }
        lazyloadHandler(){
            this.queue.forEach(imgListener=>{
                if(imgListener.state.loading) return; // 只有状态时false 才需要检测在不在页面中，在去加载
                imgListener.checkInView() && imgListener.load();
            })
        }
        add(el, dirs, vnode) {
			      //我们需要拿到父节点但是有可能为空,解决方法nexttick或者把指令的bind改成insert
            // 1.获取能滚动的元素, 我需要等待这个元素插入到dom中，在获取父级可滚动的元素
            Vue.nextTick(() => { // dom元素肯定插入到页面中， provide原理
                // 20次
                let imgListener = new ReactiveListener(el,dirs.value,this.options)
                this.queue.push(imgListener)

                if (!this.hasScrollHandler) { // 1次
                    let ele = getScrollParent(el); // 处理节流的流程
                    ele.addEventListener('scroll',this.lazyloadHandler.bind(this),{
                        passive:true
                    });
                    this.hasScrollHandler = true;
                }
                this.lazyloadHandler(); //  默认每加载一个图片都需要先检测一次
            })
        }
        unbind() {

        }
    }
}

// let fn = new X().add // 这是获取到原型add方法
// new X().add(); // 直接通过实例调用add方法
// fn();

// 我们需要有一个假的图片 -》 换成新的  onload事件  换成新的
// 监控找到能滚动的元素 ， 多次指令生成只监控一次，节流
// 我们要监控滚动的位置 -》  当前图片是否出现在可视区域内，如果出现加载图片


export default VueLazyload
```





## 三、4.15学习总结

### 1、Array.prototype.fill()学习
fill的基本用法

```JavaScript
fill 方法接受三个参数 value, start 以及 end. start 和 end 参数是可选的, 其默认值分别为 0 和 this 对象的 length 属性值。
[1, 2, 3].fill(4);               // [4, 4, 4]
[1, 2, 3].fill(4, 1);            // [1, 4, 4]
[1, 2, 3].fill(4, 1, 2);         // [1, 4, 3]
[1, 2, 3].fill(4, 1, 1);         // [1, 2, 3]
[1, 2, 3].fill(4, 3, 3);         // [1, 2, 3]
[1, 2, 3].fill(4, -3, -2);       // [4, 2, 3]
[1, 2, 3].fill(4, NaN, NaN);     // [1, 2, 3]
[1, 2, 3].fill(4, 3, 5);         // [1, 2, 3]
Array(3).fill(4);                // [4, 4, 4]
[].fill.call({ length: 3 }, 4);  // {0: 4, 1: 4, 2: 4, length: 3}

// Objects by reference.
var arr = Array(3).fill({}) // [{}, {}, {}];
// 需要注意如果fill的参数为引用类型，会导致都执行同一个引用类型
// 如 arr[0] === arr[1] 为true
arr[0].hi = "hi"; // [{ hi: "hi" }, { hi: "hi" }, { hi: "hi" }]
```

今天遇到一个需求 需要创建一个拥有N个空对象的数组
Array(5).fill({}) //创建出数组长度为5的空对象数组   [{},{},{},{},{}]

- 但是这个方法会有BUG 都是浅拷贝
>var arr = Array(3).fill({}) // [{}, {}, {}];
>// 需要注意如果fill的参数为引用类型，会导致都执行同一个引用类型
>// 如 arr[0] === arr[1] 为true
>arr[0].hi = "hi"; // [{ hi: "hi" }, { hi: "hi" }, { hi: "hi" }]

解决方法有
1. 
>let arr  = new Array(11).fill().map(()=>{return {}})
>arr[0].hi=100
>console.log(arr) //[ { hi: 100 }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} ]

2.
>let arr = Array.apply(null, { length: 11 }).map(() => ({})
>arr[0].hi=100
>console.log(arr) //[ { hi: 1002 }, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} ]

怎么理解apply(null,{length:11})
apply第二个参数不是应该是一个数组吗 为什么这里是一个对象
[](https://blog.csdn.net/weixin_34392906/article/details/88890034)
文章的直接大概就是: 然后其实第二个参数只要是个类数组对象就可以了，比如 {length: 5} 就可以看作一个类数组对象，长度是 5