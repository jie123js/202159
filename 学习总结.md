
# 每周抽出2-3天从头到尾过一遍自己的笔记
## 一、4.19学习总结
#### 1.  参数存在问题  
	很多参数需要判断到底值在不在,
	   再进行下面的方法属性,因为假如为空会浏览器报错,
	
	   所以我们可以这样做一个**短路判断**
	  number&&number.foreach()  
   ``` javascript
   number&&number.foreach() 
   ```
   这样假如没值就不会往下走了  防止出错

#### 2.   flex布局问题
	工作中用到了flex,但是忘记了主轴使用方式百度了一下
![](学习总结图片/4.19/1618846488(1).jpg)


#### 3.  参数复杂
		晚上学习node.js中 发现一个假如对象太复杂可以抽出来,
	然后假如有属性不一定有的话 可以先给传入值一个ES6默认值给null  
			例如parent_id=null

​    

![](学习总结图片/4.19/1618846520(1).jpg)

## 二、4.20学习总结
#### 1. 对象嵌套复杂
		对象里面有xxx.xxx 也可以用xxx[xxx]  对象里的是变量也是不能用.需要用[][]



#### 2、跨域问题

跨域，是指**浏览器不能执行其他网站的脚本**。它是**由浏览器的同源策略造成**的，是浏览器对JavaScript实施的安全限制。

同源策略限制了一下行为：

- Cookie无法读取
- DOM 和 JS 对象无法获取
- Ajax请求发送不出去

同源是指，域名、协议、端口均为相同

**为什么需要用到跨域？**

1、自身业务是出现很多端(前后端分离开发)   2、和第三方合作  3、面试经常问

**如何处理跨域带来的ajax问题？**(解决跨域方案)

1、jsonp  

2、设置代理服务器  （正向代理，  反向代理）

3、后端设置响应头Access-Control-Allow-Origin

```
res.setHeader("Access-Control-Allow-Origin", "*")
```

跨域代码演示：

后端代码：

```js
// 入口文件
const express = require("express");

const app = express();

app.get("/get_data",(req, res)=>{
    
    res.send({name:"node", age:"11"})
})

app.listen(3001, ()=>{
    console.log(`服务器已经启动，端口为：3001`);
})
```

html代码（右键Open in Live Server）：

```html
<!--引入JQ代码-->
<script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
```

```html
<p><span id="sp1"></span>的年龄是<span id="sp2"></span></p>
<script>
    $.ajax({
        url:'http://localhost:3001/get_data',
        type:"GET",
        success: function(data){
            $("#sp1").html(data.name)
            $("#sp2").html(data.age)
        }
    });
</script>
```

这种情况是无法访问url的 因为端口不一样

####         2.2、JSONP介绍

处理使用ajax代码发起请求外，页面某些标签也会自动发起请求。我们可以利用script标签的src属性，来发起请求。

jsonp 就是前端利用 script 在页面不刷新的情况下和服务器进行交互一种技术。拿 json 格式的数据去填充一个函数，英语：json with paddding a function 简称：jsonp

######.1、使用jsonp原理来解决跨域

前端代码：
我们在前端页面里用script标签 src 来引用请求路径 只能get 请求
```html
<p><span id="sp1"></span>的年龄是<span id="sp2"></span></p>
<script>
    function callback(data){

    	console.log("执行了callback");
        $("#sp1").html(data.name)
        $("#sp2").html(data.age)
    }    
</script>
<!-- jsonp 原理，不会出现跨域-->
<script src="http://localhost:3001/get_data"></script>
```

后端代码：
这种方法需要前后端配合,前端那个请求函数叫什么,后端也得把那个函数放在send中传出来,
如这个传出来是'callback({name:"node", age:"11"})' 然后在HTML中自调用了
```js
// 入口文件
const express = require("express");

const app = express();

app.get("/get_data",(req, res)=>{
    
    // 按照jsonp原理来响应:
    res.send('callback({name:"node", age:"11"})')
})

app.listen(3001, ()=>{
    console.log(`服务器已经启动，端口为：3001`);
})
```

####         2.3、express里的jsonp
express封装好的jsonp方法
后端代码：

```js
// 入口文件
const express = require("express");

const app = express();

app.get("/get_data",(req, res)=>{

    // express封装好的方法jsonp
    res.jsonp({name:"node", age:"11"})
})

app.listen(3001, ()=>{
    console.log(`服务器已经启动，端口为：3001`);
})
```

前端代码：
这种就不需要后端要知道前端函数名字了,比较方便
```html
<script src="http://localhost:3001/get_data?callback=callback"></script>
<!--这里第一个callback是固定，=号后面的callback是我们回调函数的名字 -->
```

####         2.4、后端设置响应头

1 直接设置响应头Access-Control-Allow-Origin

设置响应头：res.setHeader("Access-Control-Allow-Origin", "*")

后端代码：

```js
const express = require("express");

const app = express();

app.get("/get_data",(req, res)=>{

    res.setHeader("Access-Control-Allow-Origin", "*")
    res.send({name:"node", age:"11"})
})

app.listen(3001, ()=>{
    console.log(`服务器已经启动，端口为：3001`);
})
```

前端代码无需任何设置。

```html
<p><span id="sp1"></span>的年龄是<span id="sp2"></span></p>
<script>
    $.ajax({
        url:'http://localhost:3001/get_data',
        type:"GET",
        success: function(data){
            $("#sp1").html(data.name)
            $("#sp2").html(data.age)
        }
    });
</script>
```

2 使用cors模块


```js
const cors = require("cors");

app.use(cors())
```


####         2.5、设置代理服务器   
以下为vuecli中配置代理的配置 ：
官方地址：

https://cli.vuejs.org/zh/config/#devserver-proxy

  <!-- 在根目录添加一个  vue.config.js  文件-->
<!-- 重启项目 -->  
module.exports = {
	<!--  以下配置的效果
       “/api/getok.php”  ->   http://122.51.238.153/getok.php修改的配置 -->

  devServer: {
      proxy: {
          如果地址以/api开头，它就会请求到 http://122.51.238.153 
          '/api': {
              target: 'http://122.51.238.153',
              changeOrigin: true,
              ws: true, 
              pathRewrite: {
   				 '^/api': '',   //重写请求路径
 			 },
          }
      }
  }
}

target：接口域名；

changeOrigin： 如果设置为true,那么本地会虚拟一个服务端接收你的请求并代你发送该请求；
ws ： 是否代理 websockets
pathRewrite：写 /api/xx/xx. 最后代理的路径就是 http://xxx.xx.com/api/xx/xx.
不对啊, 我正确的接口路径里面没有/api啊. 所以就需要 pathRewrite,用'^/api':'', 把’/api’去掉, 这样既能有正确标识, 又能在请求接口的时候去掉/api.

#### 3、微信小程序页面布局          

	微信小程序所有页面外层都会包裹一个page 但它没有设置高度,然后又因为微信小程序用的都是flex布局是弹性盒子,
 没有给高会根据内容撑开,所以我们需要在公共样式中设置page高度100%(宽度的话默认已经设置不需要我们写)


![](学习总结图片/4.20/1618932131(1).jpg)

## 三、 4.21学习总结

#### 1、flex布局子盒子靠右贴住(方法一无效,用法2)  
![flex float 失效了](学习总结图片/4.21/微信图片_202104211941023.png)
![所以使用margin](学习总结图片/4.21/4db742a6967e82dffa5317084d3ae00.png)

#### 2、圆角border-radious 四个角使用
![](学习总结图片/4.21/微信图片_20210421194030.png) 

#### 3、为页面添加滚动条  	
![](学习总结图片/4.21/微信图片_202104211940301.png)

#### 4、 var的声明作用域和声明提升
var的作用域是函数作用域 ,意味着在函数里面的var成为函数局部作用域, 将在函数运行结束后被摧毁,不管函数有没有被调用
![](学习总结图片/4.21/微信图片_202104211941024.png)
![结果也是报错](学习总结图片/4.21/微信图片_202104211941025.png)

var a = xxx    var a会在执行的时候提到函数最上面
![](学习总结图片/4.21/微信图片_202104211940302.png)

#### 5、 手写AJAX发送请求

 obtn.onclick = () => {

        //发送ajax请求
        // 1、创建 AJAX 对象；
        let ajax = new XMLHttpRequest();
    
        // 2、设置请求路径，请求方式等；ajax.open(请求方式，路径)
        ajax.open('GET', '/get_data');
        // 3、绑定监听状态改变的处理函数，在处理函数可获取响应数据；
        ajax.onreadystatechange = ()=>{
            // 获取响应回来的数据
            if(ajax.readyState===4&& ajax.status===200){
                console.log(ajax.readyState);
                console.log(ajax.responseText);
                // 请求到数据之后，就可以把数据更新到页面上
                odiv.innerHTML = ajax.responseText;
            }
        };
        // 4、发送请求。
        ajax.send()
    }

#### 6、 数组的join()方法  
	join() 方法用于把数组中的所有元素放入一个字符串。
	
	元素是通过指定的分隔符进行分隔的。
	在本例中，我们将创建一个数组，然后把它的所有元素放入一个字符串：
	
	<script type="text/javascript">
	
	var arr = new Array(3)
	arr[0] = "George"
	arr[1] = "John"
	arr[2] = "Thomas"
	
	document.write(arr.join())
	
	</script>
	输出：
	
	George,John,Thomas  =>()什么都不加的话默认用逗号分开 (' ')引号加一个空格就是空格分开


​	
## 四、 4.22学习总结
#### 1、函数防抖


![](学习总结图片/4.22/4e26ac68d6df8edc5e95804a037aee3.png)



#### 2、 ES6模块化引入导出方式
![](学习总结图片/4.22/7765e840dc35cca1eea1bf35be79806.png)
![](学习总结图片/4.22/f9ce46f176d792f199d5b71fb1d6fd6.png)
![](学习总结图片/4.22/05ce00ee917c9ab95c9ba183b81ccf2.png)
![](学习总结图片/4.22/335daa5ea4593278ba7bf6488c25d6b.png)
总结:默认导出不能用{}导入
 #### 3、 JavaScript substring() 方法
(a,b)截取是包括a不包括b
![](学习总结图片/4.22/0a84a7fb76fbda0701c54f9bf845d65.png)

## 五、 4.23休息

## 六、 4.24学习总结

#### 1、 对象.和[]加强理解 
  为什么要用[]  因为点运算符 例如obj.name  点运算符.后面总是字符串不能是变量[]里面就可以
  对象的属性属性名都是字符串格式或者数字模式
  所以[]里面填的值,如果没有特殊是变量 想这样获取必须加""因为是字符串

#### 2、 面试之函数的节流 
```js
function throttle(callback, wait){
    //定义开始时间
    let start = 0;
    //返回结果是一个函数
    return function(e){
        //获取当前的时间戳
        let now = Date.now();
        //判断
        if(now - start >= wait){
            //若满足条件, 则执行回调函数
            callback.call(this, e);
            //修改开始时间
            start = now;
        }
    }
}



```


## 七、 4.25学习总结
今天本来学了一晚上但是学着学着突然改变了学习计划,本来是准备看好尚硅谷的VUE源码的,听的太吃力了,然后准备从今天开始为期2个月看一个,
瓜哇教育的进阶视频,所以笔记不多,第一天的瓜哇也没看完,因为时间不够,给自己来个100天挑战吧,希望100天以后可以更强
(100天争取看好珠峰JS+vue)

#### 1、面试之手写call()
```
export function call(Fn, obj, ...args){
    //判断
    if(obj === undefined || obj === null){
        obj = globalThis;// 全局对象
    }
    //为 obj 添加临时的方法
    obj.temp = Fn;
    //调用 temp 方法
    let result = obj.temp(...args);
    //删除 temp 方法
    delete obj.temp;
    //返回执行结果
    return result;
}
```



## 八、 4.26学习总结
瓜哇教育取消,因为感觉课程不怎么样,绝对开启珠峰JS希望顺利
获取属性名对应的属性值
=>对象.属性名
=>对象[属性名]  属性名是数字或者字符串格式的
=>如果当前属性名不存在，默认的属性值是undefined
=>如果属性名是数字，则不能使用点的方式获取属性值
数组是特殊的对象
   1. 我们中括号中设置的是属性值，它的属性名是默认生成的数字，从零开始递增，而且这个数字代表每一项的位置，我们把其成为“索引” =>从零开始，连续递增，代表每一项位置的数字属性名
   2. 天生默认一个属性名 length ，存储数组的长度
   3. 由此可以得出什么,对象获取属性用obj.xx 或者Obj[xx],数组又是特殊的对象,属性值是默认从0生成的,所以获取对象的值是arr[0]这种方式
## 九、 4.27学习总结(珠峰JS第二天了)
## 
#### 1、基本类型和引用类型
let a = 123 三步骤 先创建变量a 再创建值123 最后再关联
a.x = a = {n:2} 这是先 a,x与{n:2} 关联  然后再让a与{n:2}关联起来
对象也是一样的原理 
下面用2张 周老师画图增加理解
![](学习总结图片/4.27/数据类型之间的区别.png)
![](学习总结图片/4.27/阿里的面试题.png)
#### 2、 加法操作符的转换  数字和字符串和对象null和undefined和数组的互相转换
一道腾讯关于转换的面试题
JS中的加减乘除本应是进行数学运算（如果遇到的值不是数字类型，也需要基于Number()方法把其转换为数字，再进行运算）；
但是JS中加法有特殊情况：相加过程中遇到字符串直接变为字符串拼接,加法中没遇到字符串那就正常转换成数字来相加
1. Number()它是按照浏览器从底层机制，把其它数据类型转换为数字
- 字符串：看是否包含非有效数字字符,包含结果就是NaN；'  '->0；
- 布尔：true->1  false->0
- null：->0
- undefined：->NaN
- 引用类型值都要先转换为字符串再转换为数字
	+ {}/正则/函数等  ->NaN
	+ [] ->'' ->0
	+ ['12'] ->'12' ->12
	+ [12,23] ->'12,23' ->NaN
- ...

2. parseInt/parseFloat([val]) 遵循**按照字符串**从左到右查找的机制找有效数字字符（**所以传递的值一定是字符串，不是也要转换为字符串然后在查找**）
- parseInt(undefined) ->parseInt('undefined') ->NaN
- parseInt('  ') ->NaN  因为没找到有效数字字符
parseInt()函数 更专注于字符串是否包含数值模式。字符串最前面的空格会被忽 略，
从第一个非空格字符开始转换。如果第一个字符不是数值字 符、加号或减号，parseInt()立即返回NaN。
这意味着空字符串也 会返回NaN（这一点跟Number()不一样，它返回0）

![](学习总结图片/4.27/20fd8491ff6dcc4afb4427af72ad266.png)
![](学习总结图片/4.27/795c1c1e2d5364433e515bc0036e533.png)
![](学习总结图片/4.29/1619711148(1).jpg)
![](学习总结图片/4.29/1619711182(1).jpg)
![](学习总结图片/4.27/1619535015(1).jpg)
![](学习总结图片/4.27/1619535063(1).jpg)
![](学习总结图片/4.27/1619538430(1).jpg)
```
var a = 'abc' + 123 + 456;
var b = '456' - '123';
/* 相加的时候如果有任一操作数是NaN，则返回NaN；
undefined转换成数字是NAN */
/* 如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。这里[].toString为空 */
var c = 100 + true + 21.2 + null + undefined + "Tencent" + [] + null + 9 + false;
console.log(a,b,c); //abc123456 333 NaNTencentnull9false
```

#### 3、浏览器输出颜色
浏览器控制台输出的颜色


**蓝色的是数字,黑色的是字符串**

![](学习总结图片/4.27/8f5e01b68bf61fa34c956da777c4fee.png)



#### 4、typeof
  **typeof是一个运算符**
![](学习总结图片/4.27/d045dde33115a4f9144c2d0f71b41bc.png)

#### 5、三元运算符
简单的用三元
![](学习总结图片/4.27/1619535838(1).jpg)



#### 6、switch

![](学习总结图片/4.27/1619535890(1).jpg)
![](学习总结图片/4.27/1619535954(1).jpg)
**这里等价于a=1或者a=5时候 a+=2**
case得等于是默认全等===,所以有时候if的时候你用的是==,要注意区分

#### 7、z-index
当一个盒子是**父元素的子盒子**时候,想用父元素遮住子元素,只能让子元素z-index等于负数,
如果设置父元素z-index=1,子元素也会**继承**,那设置就没意义了
![](学习总结图片/4.27/731346e1d973a2f02d5d07bf255303a.png)
![](学习总结图片/4.27/b106a09e70ff54865236ff9a08ee47a.png)
![](学习总结图片/4.27/f86df0ceab9d500ac00ddf57b05b5a5.png)

#### 8、关于样式名字的问题
关于样式 html代码片段中用的是**xx-xx**  JS用的是**驼峰命名**
![](学习总结图片/4.27/912c7cdcdfae6a73e472f510a03204b.png)
![](学习总结图片/4.27/0ee08b68e1dc6b755ec42be90ca905e.png)


#### 9、关于JS修改HTML样式
通过 xxx.style.width 获取某样式的时候  HTML中行内必须要本来就有width样式.
元素对象.style.xxx=xxx 修改元素的某一个样式值（操作的是元素行内样式，
所以如果我们没有把样式写在行内上，在JS中基于.style.xxx的方式是无法获取到样式的）
![](学习总结图片/4.27/1619536585(1).jpg)


#### 10、break和continue

循环关键字break是直接退出下面代码什么也不执行 i++也不执行 


continue是后面代码不执行 i++是会执行的

![](学习总结图片/4.27/1619536786(1).jpg)
## 十、 4.28学习总结(加班到1点没学习)
   今天写项目,自己太急了,很多东西都没注意,还是太着急,需要静心!还有代码写的还是不够优雅!!!!
   代码还有很长的路需要走,加油郑杰!

## 十一、4.29学习总结
#### 1、获取DOM节点后,节点对象的属性
![](学习总结图片/4.29/1619710384(1).jpg)

#### 2、通过getElementsByTagName  
![](学习总结图片/4.29/27621f74ffcfb4c8c9bc425b768f8f7.png)


#### 3、了解console.log
console.log() 分析 为什么xx.xx 因为console是一个**对象**log是他的属性值 
所以用console.log 为什么还有个() **因为log这个属性的值是一个函数**所以需要()来执行 和传参 也叫方法(对象里面的属性值是函数的叫方法)

#### 4、JS的赋值问题
JS中值的赋值并不是单纯的赋值 而是**让变量和内存中的值进行关联**  JS是**关联赋值**
![](学习总结图片/4.29/0183cbe22e06656537689d17bb74ee1.png)
13并没有覆盖掉12,因为一开始是我们在栈内存中创建一个值12和a关联,
然后a=13又在栈内存中创建一个值13和a关联,并没有删除掉12


#### 5、腾讯面试题之NAN
![](学习总结图片/4.29/78be2b9fdda61081dfa151aac038108.png)
1. NAN与任何数字都不相等与本身都不相等
2. type of NAN 结果是number
3. parseInt转换如果遇到非数字直接NAN,但遇到123ABC换转换成123   , ABC123则不行 因为遇到非数字就报NAN
4. 关于isNaN
![](学习总结图片/4.29/1619711359(1).jpg)


#### 6、重要编程思想,自定义属性
![](学习总结图片/4.29/1619711491(1).jpg)

#### 7、css  移动问题 
如果想让元素相对自己原来位置移动 就加一个相对定位relative  
然后让left top等值调整位置,且移动后元素会覆盖其他盒子的样式
例子:
![](学习总结图片/4.29/7b28b0b721b42c2db6c19b6e0eb4d94.png)
原来有重叠部分,给上面小盒子设置
![](学习总结图片/4.29/cee41b37f2d43a4761657e6c321f6c4.png)
![](学习总结图片/4.29/1619711674(1).jpg)


#### 8、css中class选择问题
CSS中要给当前div添加class要连着写
![](学习总结图片/4.29/c9aeeb9eb66fd2c9e597c482d291e70.png)
div与.active 不能有空格 有空格就变成div子元素的.active了  
 连着写是表示div中的.active
 ![](学习总结图片/4.29/28f1ce061bcebe444c117955028ed15.png)


#### 9、解构赋值重命名
![](学习总结图片/4.29/358fca8d6222063c133b97fb035db6d.png)


#### 10、CSS奇数偶数行
CSS实现隔行变色  even偶数行   odd奇数行
![](学习总结图片/4.29/0d8a3242892c3f0435eeabc0cdc4090.png)

#### 11、取余数计算概念
小的数除以大的数余数就是小的数本身

#### 12、函数的形参
![](学习总结图片/4.29/4a8cca5d1473d468c976ae845ce143c.png)

**设置了形参没传,会默认undefined,所以我们需要在函数里面处理**,
判断假如没有传我们要设置形参为多少,判断这个最好用=== 因为2等会出现隐性转换,会不够精确, 
 ES6中可以直接在形参后面m=1直接写 就是没传等于1


#### 13、浏览器控制台打印问题(了解)
![](学习总结图片/4.29/95afb5052ccfed13b536eaa618cd2d0.png)
为什么控制台会打印东西或者输入什么东西 明明有结果还是返回一个undefined
因为浏览器是一个整体 如果有括号就把他们当成函数来执行了  **函数里面如果里面没有return 就会默认返回undefined**
例如 alert(1) 这就是一个window对象的一个方法该方法是一个函数所以用()调用,但是该函数没有返回值,就会默认返回undefined
所以是undefined

#### 14、函数的return问题

![](学习总结图片/4.29/5b92c40a3ed4d490bcc974021f3f34a.png)
return是指当前函数中return**后面所有代码都不执行了**,退出函数了
![](学习总结图片/4.29/ff59775f3e5f39a89a6535cff994a7a.png)


**函数没有写return默认返回undefined**


#### 14、匿名函数
![](学习总结图片/4.29/6db4bacc8595ac3399ee73e9d974ed1.png)

#### 15、常用的输出方式
![](学习总结图片/4.29/1619713555.jpg)

#### 16、几维的理解
![](学习总结图片/4.29/1619713619(1).jpg)
几维数组,就是外面一个数组里面包了多少对象或者数组就是几维
对象同数组

#### 17、script 位置问题
![](学习总结图片/4.29/1619713709(1).jpg)

#### 18、console.log(alert(1))问题
console.log(alert(1))  
1. alert(1)：执行浏览器内置的alert方法，执行方法的时候弹出一个"1"(方法的功能)，此方法没有返回值（默认返回值undefined）
2. console.log(undefined)





## 十二、4.30学习总结
周五休息 打游戏


## 十三、5.1学习总结
坐车的一天

#### 1、点击切换背景颜色的2种方式
1. 普通版    ![](学习总结图片/5.1/1619850881(1).jpg)
2. 函数数组思想法   ![](学习总结图片/5.1/1619850986(1).jpg)

#### 2、++运算和普通加运算字符串的区别
![](学习总结图片/5.1/1619851138(1).jpg)
++是纯粹的数字计算不会字符串拼接

#### 3、substring和slice和substr区别
![](学习总结图片/5.1/slice,substring,substr区别1.jpg)
![](学习总结图片/5.1/slice,substring,substr区别2.jpg.jpg)
slice,substring正数的时候都是从几到几不包括后面那个
substr第二个参数是表示我们要截取几个
负数的情况substring全部当0处理
substr第一个是字符串长度相减,第二个当0
slice是第一第二参数都是字符串长度和负数想减
// slice 和 substring;substring如果后面小,会自动掉成0,7   slice不会,slice返回空字符串
 console.log(a.slice(7,0));
 console.log(a.substring(7,0));
#### 4、对象的又一次加强理解
![](学习总结图片/5.1/1619858330(1).jpg)

![](学习总结图片/5.1/1619884017(1).jpg)
和ES6语法一起理解一下

#### 5、for-in理解
![](学习总结图片/5.1/1619884138(1).jpg)
ECMAScript中对象的属性是无序的，因此for-in语句**不能保证返回对象 属性的顺序**。
换句话说，所有可枚举的属性**都会返回一次**，但返回的顺 序可能会因浏览器而异。

## 十四、5.2学习总结

#### 1、自定义属性编程思想(又一次)
![](学习总结图片/5.2/61ab0f62eefa1399e1d64faaa9b312f.png)
![](学习总结图片/5.2/深刻理解元素对象和元素对象集合.png)

#### 2、函数的运行机制
![](学习总结图片/5.2/函数的深入理解.png)
res = null 表示res和谁都不关联 空指针

函数只创建不执行可以吗 可以 只是没意义 报错吗 不报错 因为创建的时候只是开了一个堆 把函数里面的代码当成字符串存起来了
 所以FN代表当前函数本身 FN()代表当前函数执行 具体代表return后面的值 
 函数执行一定得有结果吗 那个结果就是return后面的值 
 想看一个函数的返回的值是谁 只要看return后面的值 
 如果有return后面是啥就是啥 没有return就是undefined
 函数每次执行都是把代码从头来一遍 
 每一次都是形成一个全新的私有栈内存 
 外面想用只能函数本身return出去

#### 3、自定义属性编程属性加函数的运行机制(通过选项卡)
![](学习总结图片/5.2/1619935911(1).jpg)
![](学习总结图片/5.2/选项卡运行原理图.png)

#### 4、函数的arguments
![](学习总结图片/5.2/1619938624.jpg)

#### 5、箭头函数(初体验)
有的时候可能会看到=>xx=>xx其实是这样的
![](学习总结图片/5.2/1619940302(1).jpg)

...arg运算符  箭头函数里面没有arguments但是有...arg  这个arg不是伪数组  可以直接用数组的方法
![](学习总结图片/5.2/1619940473(1).jpg)

#### 6、如何基于Math.max/min获取数组中的最大值最小值？
1 . Math.min.apply(null, arr)

>>>Math.min.apply(null, [2,1,3])
<<<1

唉？不是不能接收数组类型的参数吗？这是apply方法的特性，apply方法第二个参数为参数的数组，明白了吧，虽然我们传入的是数组参数，但是apply会将数组拆分并传入调用的函数。可以说是比较巧的用法了。

2 . Math.min(...[v1, v2...])

>>>Math.min(...[2,1,3])
<<<1

这里的…（三个点）是ES6中的用法，有兴趣的可以去了解一下，低版本的JS并不支持这种用法。

#### 7、Math的常用方法
1.  Math.abs([number value])       ![](学习总结图片/5.2/1619954644.jpg)

2.  Math.ceil **(向上取整)(ceil就是要比原来的数大)**/ floor**(向下取整)(floor要比原来的数小)**([number value])   (ceil就是要比原来的数大)  ![](学习总结图片/5.2/1619954709(1).jpg)

3.  Math.round() (四舍五入)    ![](学习总结图片/5.2/1619954763(1).jpg)


4.  Math.max / min ([val1],[val2],...)     > 获取一堆数中的最大值和最小值   



5. Math.sqrt / pow()



> sqrt：给一个数开平方
>
> pow：计算一个数的多少次幂
```javascript
console.log(Math.sqrt(9)); //=>3  符合N*N=M 这样的M才能整开平方
console.log(Math.sqrt(-9)); //=>NaN 负数开不了平方
console.log(Math.pow(2, 10)); //=>1024
```

6. Math.random()

> 获取0~1之间的随机小数

```javascript
for (let i = 1; i <= 10; i++) {
	console.log(Math.random());
}
/*
 * 0.09453770227521763
 * 0.06700581113042259
 * 0.10092020814995206
 * ...
 */
```

#### 8、随机获取(n~m)中的随机整数
扩展：获取 [n~m] 之间的随机整数

> 包含n也包含m
>
> n<m
```javascript
Math.round(Math.random()*(m-n)+n)
```

#### 9、数组的常用方法改变原数组的增删改查
> 这一部分方法都会修改原有的数组
**1.实现数组增删改的方法**
`push`     也可以用原生实现ary[ary.length]

```javascript
/*
 * push : 向数组末尾增加内容
 * @params
 *   多个任意类型
 * @return
 *   新增后数组的长度 
 */
let ary = [10, 20];
let res = ary.push(30, 'AA');
// 基于原生JS操作键值对的方法，也可以向末尾追加一项新的内容
ary[ary.length] = 40;
console.log(res, ary); //=>4 [10,20,30,'AA',40]
```

`unshift`    不可以用原生 但是可以用ES6...展开运算符

```javascript
/*
 * unshift : 向数组开始位置增加内容
 * @params
 *   多个任意类型
 * @return
 *   新增后数组的长度 
 */
let ary = [10, 20];
let res = ary.unshift(30, 'AA');
console.log(res, ary); //=>4  [30,'AA',10,20]

// 基于原生ES6展开运算符，把原有的ARY克隆一份，在新的数组中创建第一项，其余的内容使用原始ARY中的信息即可，也算实现了向开始追加的效果
ary = [100, ...ary];
console.log(ary); //=>[100,30,'AA',10,20]
```

`shift`   基于原生的不能实现

```javascript
/*
 * shift : 删除数组中的第一项
 * @params
 * @return
 *   删除的那一项 
 */
let ary = [10, 20, 30, 40];
let res = ary.shift();
console.log(res, ary); //=>10  [20, 30, 40]

// 基于原生JS中的DELETE，把数组当做普通的对象，确实可以删除掉某一项内容，但是不会影响数组本身的结构特点（length长度不会跟着修改）,真实项目中杜绝这样的删除使用
delete ary[0];
console.log(ary); //=>{1:30,2:40,length:3}
```

`pop`   可以原生实现

```javascript
/*
 * pop : 删除数组中的最后一项
 * @params
 * @return
 *   删除的那一项 
 */
let ary = [10, 20, 30, 40];
let res = ary.pop();
console.log(res, ary); //=>40  [10,20,30]

// 基于原生JS让数组数组长度干掉一位，默认干掉的就是最后一项
ary.length--; //=>ary.length = ary.length - 1;
console.log(ary);
```

`splice`

```javascript
/*
 * splice : 实现数组的增加、删除、修改
 * @params
 * 	 n,m 都是数字  从索引n开始删除m个元素（m不写，是删除到末尾）
 * @return
 *   把删除的部分用新数组存储起来返回 
 */
let ary = [10, 20, 30, 40, 50, 60, 70, 80, 90];
let res = ary.splice(2, 4);
console.log(res, ary); //=>[30, 40, 50, 60]  [10, 20, 70, 80, 90]

// 基于这种方法可以清空一个数组，把原始数组中的内容以新数组存储起来（有点类似数组的克隆：把原来数组克隆一份一模一样的给新数组）
/* res = ary.splice(0);
console.log(res, ary);//=>[10, 20, 70, 80, 90] [] */

// 删除最后一项和第一项
ary.splice(ary.length - 1);
ary.splice(0, 1);
console.log(ary);
```

```javascript
/*
 * splice : 实现数组的增加、修改
 * @params
 * 	 n,m,x  从索引n开始删除m个元素，用x占用删除的部分
 *   n,0,x  从索引n开始，一个都不删，把x放到索引n的前面
 * @return
 *   把删除的部分用新数组存储起来返回 
 */
let ary = [10, 20, 30, 40, 50];
let res = ary.splice(1, 2, '珠峰培训', '哈哈哈');
console.log(res, ary); //=> [20,30] [10,'珠峰培训','哈哈哈', 40, 50]

// 实现增加
//单纯的增加是索引前面那个位置,比如从索引3开始删除0个那就是索引3的值40前面增加呵呵呵
ary.splice(3, 0, '呵呵呵');
console.log(ary); //=>[10, "珠峰培训", "哈哈哈", "呵呵呵", 40, 50]

// 向数组末尾追加
ary.splice(ary.length, 0, 'AAA');

// 向数组开始追加
ary.splice(0, 0, 'BBB');
```


## 十五、5.3学习总结(劳动节忙学的少)

#### 1、数组常用的查询和拼接
**2.数组的查询和拼接**
> 此组学习的方法，原来数组不会改变

`slice`

```javascript
/*
 * slice : 实现数组的查询
 * @params
 * 	 n,m 都是数字 从索引n开始，找到索引为m的地方（不包含m这一项）
 * @return
 *   把找到的内容以一个新数组的形式返回 
 */
let ary = [10, 20, 30, 40, 50];
let res = ary.slice(1, 3);
console.log(res); //=>[20,30]

// m不写是找到末尾
res = ary.slice(1);
console.log(res); //=>[20, 30, 40, 50]

// **数组的克隆，参数0不写也可以**
res = ary.slice(0);
console.log(res); //=>[10, 20, 30, 40, 50]

// 思考：1.如果n/m为负数会咋地，如果n>m了会咋地，如果是小数会咋地，如果是非有效数字会咋地，如果m或者n的值比最大索引都会咋地？ 2.这种克隆方式叫做浅克隆，可以回去先看看深度克隆如何处理!
```

`concat`

```javascript
/*
 * concat : 实现数组拼接
 * @params
 * 	 多个任意类型值
 * @return
 *   拼接后的新数组（原来数组不变） 
 */
let ary1 = [10, 20, 30];
let ary2 = [40, 50, 60];
let res = ary1.concat('珠峰培训', ary2);
console.log(res);
```

**3.把数组转换为字符串**

> 原有数组不变

`toString`

```javascript
/*
 * toString : 把数组转换为字符串
 * @params
 * @return
 *   转换后的字符串，每一项用逗号分隔（原来数组不变） 
 */
let ary = [10, 20, 30];
let res = ary.toString();
console.log(res); //=>"10,20,30"
console.log([].toString()); //=>""
console.log([12].toString()); //=>"12"
```

`join`

```javascript
/*
 * join : 把数组转换为字符串
 * @params
 *   指定的分隔符（字符串格式）
 * @return
 *   转换后的字符串（原来数组不变） 
 */
let ary = [10, 20, 30];
let res = ary.join('');
console.log(res); //=>"102030"

res = ary.join();
console.log(res); //=>"10,20,30"

res = ary.join('|');
console.log(res); //=>"10|20|30"

res = ary.join('+');
console.log(res); //=>"10+20+30"
console.log(eval(res)); //=>60  eval把字符串变为JS表达式执行
```

**4.检测数组中的是否包含某一项**

`indexOf / lastIndexOf / includes`

```javascript
/*
 * indexOf / lastIndexOf : 检测当前项在数组中第一次或者最后一次出现位置的索引值（在IE6~8中不兼容）
 * @params
 *   要检索的这一项内容
 * @return
 *   这一项出现的位置索引值（数字），如果数组中没有这一项，返回的结果是-1
 * 原来数组不变
 */
let ary = [10, 20, 30, 10, 20, 30];
console.log(ary.indexOf(20)); //=>1
console.log(ary.lastIndexOf(20)); //=>4

// 想验证ARY中是否包含'珠峰培训'
if (ary.indexOf('珠峰培训') === -1) {
	// 不包含
}
// 也可以直接使用ES6新提供的includes方法判断
if (ary.includes('珠峰培训')) {
	// 包含：如果存在返回的是TRUE
}
```

**5.数组的排序或者排列**

`reverse`

```javascript
/*
 * reverse : 把数组倒过来排列
 * @params
 * @return
 *   排列后的新数组
 * 原来数组改变
 */
let ary = [12, 15, 9, 28, 10, 22];
ary.reverse();
console.log(ary); //=>[22, 10, 28, 9, 15, 12]
```

`sort`

```javascript
/*
 * sort : 实现数组的排序
 * @params
 *   可以没有，也可以是个函数
 * @return
 *   排序后的新数组
 * 原来数组改变
 */
let ary = [7, 8, 5, 2, 4, 6, 9];
ary.sort();
console.log(ary); //=>[2, 4, 5, 6, 7, 8, 9]

// SORT方法中如果不传递参数，是无法处理10以上数字排序的(它默认按照每一项第一个字符来排，不是我们想要的效果)
/* ary = [12, 15, 9, 28, 10, 22];
ary.sort();
console.log(ary); //=> [10, 12, 15, 22, 28, 9] */

// 想要实现多位数正常排序，需要给SORT传递一个函数，函数中返回 a-b 实现升序，返回 b-a 实现降序
ary = [12, 15, 9, 28, 10, 22];
// ary.sort(function(a,b){ return a-b; });
ary.sort((a, b) => a - b);
console.log(ary);
```

**6.遍历数组中每一项的方法**

`forEach`

```javascript
/*
 * forEach：遍历数组中的每一项内容
 * @params
 *    回调函数
 * @return
 * 
 * 原来数组不变 
 */
let ary = [12, 15, 9, 28, 10, 22];

/* // 基于原生JS中的循环可以实现
for (let i = 0; i < ary.length; i++) {
	// i:当前循环这一项的索引
	// ary[i]:根据索引获取循环的这一项
	console.log('索引：' + i + ' 内容：' + ary[i]);
} */

ary.forEach((item, index) => {
	// 数组中有多少项，函数就会被默认执行多少次
	// 每一次执行函数：item是数组中当前要操作的这一项，index是当前项的索引
	console.log('索引：' + index + ' 内容：' + item);
});
```



## 十六、5.4学习总结(劳动节参加婚礼没有学习)

## 十七、5.5学习总结(回来杭州站票直接累的困死)
5.6号开始一定要全力以赴

## 十八、5.6号学习总结(五月份,活是真的多,很忙,但是也要加油)

#### 1、数组去重的稍微笨重的方法
方案一
这个方案和indexOf==-1,差不多的,但是这里有一个**if 加continue 的思路**可以学习

```javascript
/*
 * 方案一：
 *   循环原有数组中的每一项，每拿到一项都往新数组中添加
 *   添加之前验证新数组中是否存在这一项，不存在再增加
 */
let newAry = [];
for (let i = 0; i < ary.length; i++) {
	// 循环获取原有数组中的每一项
	let item = ary[i];
	// 验证新数组中是否存在这一项
	if (newAry.includes(item)) {
		// 存在这一项，不在增加到新数组中，继续下一轮循环即可
		continue;
	}
	// 新数组中不存在这一项，我们加入到新数组中即可
	newAry.push(item);
}
console.log(newAry);
```

```javascript
//简化代码
let newAry = [];
ary.forEach(item => {
	if (newAry.includes(item)) return;
	newAry.push(item);
});
console.log(newAry);
```

方案二
这个方案需要运用2个循环 进行前后对比,然后运用splice方法删除重复项,但是会出现**数组塌陷**的问题,
但是没有兼容性问题了(虽然现在也已经抛弃IE6,7,8了)
```javascript
/*
 * 方案二：
 *  先分别拿出数组中的每一项A
 *  用这一项A和“它后面的每项”依次进行比较，如果遇到和当前项A相同的，则在原来数组中把这一项移除掉
 * 
 * 不用includes/indexOf（这样保证兼容性）
 */
var ary = [1, 2, 3, 1, 2, 1, 2, 3, 2, 1, 2, 3];
for (var i = 0; i < ary.length; i++) {
	// item：每一次循环拿出来的当前项
	// i：当前项的索引  i+1：代表后一项
	var item = ary[i];
	// 让当前项和后面的每一项进行比较(循环)
	for (var j = i + 1; j < ary.length; j++) {
		// compare：后面拿出来要比较的每一项
		var compare = ary[j];
		// 如果compare和item相等，说明这一项是重复的，我们把它删掉
		if (compare === item) {
			// j索引这一项要从数组中移除
			ary.splice(j, 1);
			// 数组塌陷了：j后面的每一项索引都提前了一位，下一次要比较的应该还是j这个索引的内容
			j--;
		}
	}
}
console.log(ary);
```

#### 2、数组去重比较好的办法(封装了一个去重函数)

1. 方案一 运用了对象没有重复的键的特点,用**数组的值当对象的键值对(键和值是相等的)**
```javascript
let ary = [1, 2, 3, 1, 2, 1, 2, 3, 2, 1, 2, 3];
// 1.创建一个空对象
let obj = {};
// 2.循环数组中的每一项，把每一项向对象中进行存储 => item:item
for (let i = 0; i < ary.length; i++) {
	let item = ary[i];
	// 3.每一次存储之前进行判断:验证obj中是否存在这一项
	if (obj[item] !== undefined) {
		// 已经存在这一项
		ary.splice(i, 1);
		i--;
		continue;
	}
	obj[item] = item;
}
console.log(ary);
```

> 基于splice实现删除性能不好：当前项被删后，后面每一项的索引都要向前提一位，**如果后面内容过多，一定影响性能**
> 方案二 用了一个小技巧 **把删除的索引位置和值换成数组最后一项**

```javascript
/*
 * unique：实现数组去重的方法
 *  @params
 *     ary [Array] 要去重的数组
 *  @return
 *     [Array] 去重后的数组
 * by zhouxiaotian on 20190724   
 */
function unique(ary) {
	let obj = {};
	for (let i = 0; i < ary.length; i++) {
		let item = ary[i];
		if (obj[item] !== undefined) {
			ary[i] = ary[ary.length - 1];
			ary.length--;//就是把最后一项删除,方法很多也可以用pop
			i--;
			continue;
		}
		obj[item] = item;
	}
	return ary;
}
let aa = [12, 23, 12, 15, 25, 23, 25, 14, 16];
aa = unique(aa);
aa.sort((a, b) => a - b);
console.log(aa); //=>[12, 14, 15, 16, 23, 25]
```


#### 3、数组去重ES6简便方法
**基于ES6的Set（对应的Map）实现去重**
let ary = [12, 23, 12, 15, 25, 23, 25, 14, 16];
ary = [...new Set(ary)];   先用Set获得一个去重的数组对象,然后用扩展运算符变成真数组,记得要用[]包起来

console.log(ary);

#### 4、字符串常用方法
**字符串的方法都是复制出值,不会对原来的字符串进行修改**
> 所有用 单引号、双引号、反引号 包起来的都是字符串

**字符串也有索引和length**
```javascript
let str = 'zhufengpeixunyangfanqihang';
// 每一个字符串都是由零到多个字符组成的
str.length //=>字符串长度
str[0] //=>获取索引为零（第一个）字符
str[str.length-1] //=>获取最后一个字符str.length-1最后一项索引
str[10000] //=>undefined 不存在这个索引

//循环输出字符串中的每一个字符
for (let i = 0; i < str.length; i++) {
	let char = str[i];
	console.log(char);
}
```

`charAt / charCodeAt`
charCodeAt不常用
charAt：**根据索引获取指定位置的字符**
**与str[xx]区别是charAt(xx)假如没有这个索引返回空字符串'',str[xx]没有返回undefined**
```javascript
/*
 * charAt：根据索引获取指定位置的字符
 * charCodeAt：获取指定字符的ASCII码值（Unicode编码值）
 *  @params
 * 	   n [number] 获取字符指定的索引
 *  @return 
 *     返回查找到的字符
 *     找不到返回的是空字符串不是undefined，或者对应的编码值 
 */
let str = 'zhufengpeixunyangfanqihang';
console.log(str.charAt(0)); //=>'z'
console.log(str[0]); //=>'z'
console.log(str.charAt(10000)); //=>''
console.log(str[10000]); //=>undefined
console.log(str.charCodeAt(0)); //=>122
console.log(String.fromCharCode(122)); //=>'z'
```

`substr / substring / slice`

```javascript
/*
 * 都是为了实现字符串的截取（在原来字符串中查找到自己想要的）
 * 	 substr(n,m)：从索引n开始截取m个字符，m不写截取到末尾（后面方法也是）
 *   substring(n,m)：从索引n开始找到索引为m处(不含m)
 *   slice(n,m)：和substring一样，都是找到索引为m处，但是slice可以支持负数作为索引，其余两个方法是不可以的
 */
let str = 'zhufengpeixunyangfanqihang';
console.log(str.substr(3, 7)); //=>'fengpei'
console.log(str.substring(3, 7)); //=>'feng'
console.log(str.substr(3)); //=>'fengpeixunyangfanqihang' 截取到末尾
console.log(str.substring(3, 10000)); //=>'fengpeixunyangfanqihang' 截取到末尾（超过索引的也只截取到末尾）

console.log(str.substring(3, 7)); //=>'feng'
console.log(str.slice(3, 7)); //=>'feng'
console.log(str.substring(-7, -3)); //=>'' substring不支持负数索引
console.log(str.slice(-7, -3)); //=>'nqih' slice支持负数索引 =>快捷查找：负数索引，我们可以按照 STR.LENGTH+负索引 的方式找   =>slice(26-7,26-3)  =>slice(19,23)
```

`indexOf / lastIndexof / includes`

```javascript
/*
 * 验证字符是否存在
 * 	 indexOf(x,y)：获取x第一次出现位置的索引，y是控制查找的起始位置索引
 *   lastIndexOf(x)：最后一次出现位置的索引
 *   =>没有这个字符，返回的结果是-1
 */
let str = 'zhufengpeixunyangfanqihang';
console.log(str.indexOf('n')); //=>5
console.log(str.lastIndexOf('n')); //=>24

console.log(str.indexOf('@')); //=>-1 不存在返回-1
if (str.indexOf('@') === -1) {
	// 字符串中不包含@这个字符
}

console.log(str.indexOf('feng')); //=>3  验证整体第一次出现的位置，返回的索引是第一个字符所在位置的索引值
console.log(str.indexOf('peiy')); //=>-1

console.log(str.indexOf('n', 7)); //=>12 查找字符串索引7及之后的字符串中，n第一次出现的位置索引	

if (!str.includes('@')) {
	console.log('当前字符串不包含@');
}
```

`toUpperCase / toLowerCase`

```javascript
/*
 * 字符串中字母的大小写转换
 * 	 toUpperCase()：转大写
 *   toLowerCase()：转小写
 */
let str = 'ZhuFengPeiXunYangFanQiHang';
str = str.toUpperCase();
console.log(str); //=>'ZHUFENGPEIXUNYANGFANQIHANG'

str = str.toLowerCase();
console.log(str); //=>'zhufengpeixunyangfanqihang'

// 实现首字母大写
str = str.substr(0, 1).toUpperCase() + str.substr(1);
console.log(str); //=>'Zhufengpeixunyangfanqihang'
```

`split`

```javascript
/*
 * split([分隔符]):把字符串按照指定的分隔符拆分成数组（和数组中join对应）
 * 
 * split支持传递正则表达式 
 */
// 需求：把|分隔符变为,分隔符
let str = 'music|movie|eat|sport';
let ary = str.split('|'); //=>["music", "movie", "eat", "sport"]
str = ary.join(',');
console.log(str); //=>"music,movie,eat,sport"
```

`replace`
**replace只会替换第一次出现的,所以需要配合正则比较好用**
```javascript
/*
 * replace(老字符,新字符)：实现字符串的替换（经常伴随着正则而用）
 */
let str = '珠峰@培训@扬帆@起航';
// str = str.replace('@', '-');
// console.log(str); //=>"珠峰-培训@扬帆@起航" 在不使用正则表达式的情况下，执行一次REPLACE只能替换一次字符

str = str.replace(/@/g, '-');
console.log(str); //=>珠峰-培训-扬帆-起航
```
还有一些方法,以后慢慢学
`match`

`localCompare`

`trim / trimLeft / trimRight`

...

控制台输出 String.prototype 查看所有字符串中提供的方法


## 十九、5.7号学习总结(状态好像不是很好!!!下半场加油)

#### 1、分装一个获取url参数的函数


```javascript
/* 
 * queryURLParams：获取URL地址中问号传参的信息和哈希值
 *   @params
 *      url [string] 要解析的URL字符串
 *   @return
 *      [object] 包含参数和哈希值信息的对象
 * by zhouxiaotian on 2019/07/24 16:29:00
 */
function queryURLParams(url) {
	//1.获取?和#后面的信息
	let askIn = url.indexOf('?'),
		wellIn = url.indexOf('#'),
		askText = '',
		wellText = '';
	// #不存在
	wellIn === -1 ? wellIn = url.length : null;
	// ?存在
	askIn >= 0 ? askText = url.substring(askIn + 1, wellIn) : null;
	wellText = url.substring(wellIn + 1);

	//2.获取每一部分信息
	let result = {};
	wellText !== '' ? result['HASH'] = wellText : null;
	if (askText !== '') {
		let ary = askText.split('&');
		ary.forEach(item => {
			let itemAry = item.split('=');
			result[itemAry[0]] = itemAry[1];
		});
	}
	return result;
}

/* 
//基于正则封装的才是最完美的(后面学)
function queryURLParams(url) {
	let result = {},
		reg1 = /([^?=&#]+)=([^?=&#]+)/g,
		reg2 = /#([^?=&#]+)/g;
	url.replace(reg1, (n, x, y) => result[x] = y);
	url.replace(reg2, (n, x) => result['HASH'] = x);
	return result;
} 
*/

let aa = 'http://www.zhufengpeixun.cn/index.html?lx=1&name=zhufeng&teacher=aaa#box';
let paramsObj = queryURLParams(aa);
console.log(paramsObj);
```


#### 2、日期对象基础知识总结
 new Date() **获取的本台计算机的时间,不是公共时间**;
 new Date()**获取的时间是对象**
```javascript
let time = new Date();
/*
 * 获取当前客户端（本机电脑）本地的时间
 *    这个时间用户是可以自己修改的，所以不能作为重要的参考依据
 * 
 * Fri Jul 26 2019 10:02:17 GMT+0800 (中国标准时间)
 *    获取的结果不是字符串是对象数据类型的，属于日期对象(或者说是Date这个类的实例对象)
 */
typeof time;  //=>"object"
```

标准日期对象中提供了一些属性和方法，供我们操作日期信息

- getFullYear()  获取年
- getMonth()  获取月   结果是0~11代表第一月到第十二月
- getDate()  获取日 

- getDay()  获取星期   结果是0~6代表周日到周六
- getHours() 获取时   
- getMinutes() 获取分
- getSeconds() 获取秒
- getMilliseconds() 获取毫秒
- getTime() 获取当前日期距离1970/1/1 00:00:00 这个日期之间的毫秒差
- toLocaleDateString()  获取年月日（字符串）
- toLocaleString()  获取完整的日期字符串      

#### 3、日期对象的小时钟案例(还有一个有趣的CSS渐变色)
1. **要记住定时器里面放的是函数!不用加括号,加了括号就自执行了,就变成函数return的结果了**
2. **获得的月数是获取月   结果是0~11代表第一月到第十二月**
3. **获取星期   结果是0~6代表周日到周六**
```html
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>小时钟</title>
	<!-- IMPORT CSS -->
	<style>
		* {
			margin: 0;
			padding: 0;
		}
		#clockBox {
			position: absolute;
			right: 0;
			top: 0;
			padding: 0 15px;
			line-height: 70px;
			font-size: 24px;
			color: darkred;
			/* 设置背景渐变色 */
			background: lightblue;
			background: -webkit-linear-gradient(top left, lightblue, lightcoral, lightcyan);
		}
	</style>
</head>
<body>
	<div id="clockBox">
		2019年07月26日 星期五 10:25:03
	</div>
	<!-- IMPORT JS -->
	<script>
		let clockBox = document.getElementById('clockBox');
		/* 
		 * addZero:不足十补充零
		 *   @params
		 *      val需要处理的值
		 *   @return
		 		处理后的结果（不足十位的补充零）
		 * by Team on 2019/07/26
		 */
		function addZero(val) {
			val = Number(val);
			return val < 10 ? '0' + val : val;
		}
        
		/* 
		 * queryDate:获取当前的日期，把其转换为想要的格式
		 *   @params
		 *   @return
		 * by Team on 2019/07/26
		 */
		function queryDate() {
			// 1.获取当前日期及详细信息
			let time = new Date(),
				year = time.getFullYear(),
				month = time.getMonth() + 1,
				day = time.getDate(),
				week = time.getDay(),
				hours = time.getHours(),
				minutes = time.getMinutes(),
				seconds = time.getSeconds();
			let weekAry = ['日', '一', '二', '三', '四', '五', '六'];
			// 2.拼凑成我们想要的字符串
			let result = year + "年" + addZero(month) + "月" + addZero(day) + "日";
			result += " 星期" + weekAry[week] + " ";
			result += addZero(hours) + ":" + addZero(minutes) + ":" + addZero(seconds);
			// 3.把处理好的结果放到盒子中
			clockBox.innerHTML = result;
		}
		// 加载页面执行方法
		queryDate();
		// 定时器控制运动：设置一个setInterval定时器（到达指定时间干什么事情的东西就是定时器），每隔1000MS执行queryDate方法
		setInterval(queryDate, 1000);
	</script>
</body>
</html>
```



## 二十、5.8号学习总结(工作日最后一天休息)


## 二十一、5.9号学习总结


#### 1、实现一个最简陋的4位数字验证码

> 实现一个最LOW的验证码：数字+字母共四位
>
> 验证码目的：防止外挂程序恶意批量注入的

 ```html
<body>
	<input type="text" id="codeInp">
	<br>
	<span id="codeBox">AAAA</span>
	<button id="changeCode">看不清换一张</button>

	<!-- IMPORT JS -->
	<script>
		let codeInp = document.getElementById('codeInp'),
			codeBox = document.getElementById('codeBox'),
			changeCode = document.getElementById('changeCode');

		/*
		 * queryCode：获取到四位随机验证码，然后放到指定的盒子中
		 *   @params
		 *   @return
		 * by Team on 2019/07/24  
		 */
		function queryCode() {
			// 准备获取范围的字符串 0~61
			let area = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
			let result = "";
			for (let i = 0; i < 4; i++) {
				// 每一次循环都获取一个随机的数字索引
				let ran = Math.round(Math.random() * 61);
				// 再根据获取的索引从范围字符串中找到对应的字符，把找到的字符拼接到最后的结果中
				result += area.charAt(ran);
			}
			// 放到盒子里面
			codeBox.innerHTML = result;
		}

		// 第一次加载页面需要执行方法，让其显示在页面中
		queryCode();

		// 点击看不清按钮，需要重新执行方法生成新的验证码
		changeCode.onclick = queryCode;

		// 文本框失去焦点的时候：验证用户输入的内容和验证码是否相同，给予相关的提示，如果不一样需要重新生成验证码
		// onblur：文本框失去焦点事件
		codeInp.onblur = function () {
			// 获取用户和验证码内容（表单元素.value / 非标单元素.innerHTML 获取内容）
			let val = codeInp.value,
				code = codeBox.innerHTML;
			// 不区分大小写的验证（都转成小写）
			if (val.toLowerCase() === code.toLowerCase()) {
				alert('温馨提示：验证码输入成功！');
			} else {
				alert('温馨提示：验证码输入有误，请重试！');
				codeInp.value = '';
				// 重新生成验证码
				queryCode();
			}
		}
	</script>
</body>
 ```
 
#### 2、时间字符串格式化案例(以及封装一个时间组件(这需要以后正则学了来理解))


> new Date() 除了获取本机时间，还可以把一个时间格式字符串转换为标准的时间格式

```javascript
new Date("2019/7/26");
//=>Fri Jul 26 2019 00:00:00 GMT+0800 (中国标准时间)

/*
 * 支持的格式
 *    yyyy/mm/dd
 *    yyyy/mm/dd hh:mm:ss
 *    yyyy-mm-dd 这种格式在IE下不支持
 */
```

**时间字符串格式化案例**

> 字符串处理解决办法

```javascript
// =>不足十位补充零
let addZero = val => {
	val = Number(val);
	return val < 10 ? '0' + val : val;
};

/*
* 字符串处理解决办法
*/
function formatTime(time) {
    // 1.先获取年月日等信息
    let ary = time.split(' '),
    	aryLeft = ary[0].split('-'),
    	aryRight = ary[1].split(':');
    ary = aryLeft.concat(aryRight);
    // 2.拼接成为我们想用的格式
    let result = ary[0] + "年" + addZero(ary[1]) + "月" + addZero(ary[2]) + "日";
    result += " " + addZero(ary[3]) + ":" + addZero(ary[4]) + ":" + addZero(ary[5]);
    return result;
}
let time = '2019-5-30 12:0:0'; 
time = formatTime(time);
console.log(time);
// =>"2019年05月30日 12:00:00"
```

> 基于日期对象处理

```javascript
/*
 * 基于日期对象处理 
 */
function formatTime(time) {
    // 1.把时间字符串变为标准日期对象
    time = time.replace(/-/g, '/');
    time = new Date(time);
    // 2.基于方法获取年月日等信息
    let year = time.getFullYear(),
        month = addZero(time.getMonth() + 1),
        day = addZero(time.getDate()),
        hours = addZero(time.getHours()),
        minutes = addZero(time.getMinutes()),
        seconds = addZero(time.getSeconds());
    // 3.返回想要的结果
    return year + "年" + month + "月" + day + "日 " + hours + ":" + minutes + ":" + seconds;
}
let time = '2019-5-30 12:0:0';
time = formatTime(time);
console.log(time);
// =>"2019年05月30日 12:00:00"
```

> 封装一套公共的时间字符串格式化处理的方式 

```javascript
/*
 * 封装一套公共的时间字符串格式化处理的方式 
 */
String.prototype.formatTime = function formatTime(template) {
    // 初始化模板
    typeof template === 'undefined' ? template = "{0}年{1}月{2}日 {3}:{4}:{5}" : null;
    // this:我们要处理的字符串
    // 获取日期字符串中的数字信息
    let matchAry = this.match(/\d+/g);
    // 模板和数据的渲染（引擎机制）
    template = template.replace(/\{(\d+)\}/g, (x, y) => {
    	let val = matchAry[y] || '00';
    	val.length < 2 ? val = '0' + val : null;
    	return val;
	});
	return template;
};
let time = '2019-5-30 12:0:0';
console.log(time.formatTime("{1}-{2} {3}:{4}"));
// =>"2019年05月30日 12:00:00"
```

#### 3、DOM及其基础操作

> DOM：document object model 文档对象模型，提供一些属性和方法供我们操作页面中的元素

**获取DOM元素的方法**

- document.getElementById()  指定在文档中，基于元素的ID或者这个元素对象  ==>ID这种的
- [context].getElementsByTagName()  在指定上下文(容器)中，通过标签名获取一组元素集合 ==>DIV这种的

- [context].getElementsByClassName()  在指定上下文中，通过样式类名获取一组元素集合 （不兼容IE6~8） ==>class这种的
- document.getElementsByName()  在整个文档中，通过标签的NAME属性值获取一组节点集合(<input type="radio" name="sex" value="男" checked>) （在IE中只有表单元素的NAME才能识别，所以我们一般只应用于表单元素的处理）
- document.head / document.body / document.documentElement 获取页面中的 HEAD/BODY/HTML 三个元素
- [context].querySelector([selector])  在指定上下文中，通过选择器获取到指定的元素对象
- [context].querySelectorAll([selector])  在指定上下文中，通过选择器获取到指定的元素集合

```javascript
//=> querySelector / querySelectorAll 不兼容IE6~8
let box = document.querySelector('#box');
let links = box.querySelectorAll('a');
// links=document.querySelectorAll('#box a');
let aas=document.querySelectorAll('.aa');
 let navList = document.querySelectorAll('.tab li');       //tab下所有的li
 let divList = document.querySelectorAll('.tabBox>div');     //tabBox下的亲儿子div  孙子的不算
```

#### 4、节点与节点之间的关系

**JS中的节点和描述节点之间关系的属性**

> 节点 ： Node （页面中所有的东西都是节点）
>
> 节点集合：NodeList  （getElementsByName / querySelectorAll 获取的都是节点集合）

- 元素节点 （元素标签）
  + nodeType：1
  + nodeName : 大写的标签名
  + nodeValue ：null
- 文本节点
  - nodeType：3
  - nodeName : '#text'
  - nodeValue ：文本内容
- 注释节点
  - nodeType：8
  - nodeName : '#commen'
  - nodeValue ：注释内容
- 文档节点 document
  - nodeType：9
  - nodeName : '#document'
  - nodeValue ：null
- ......

描述这些节点之家关系的属性

- childNodes ：获取所有的子节点(文字,隔行,div全部获取)   标准浏览器（非IE6~8）中会把空格和换行当做文本节点处理 （childNodes包含所有节点）
- children：获取所有的元素子节点（子元素标签集合） ==>只获取div li span 类似的这种标签
- parentNode：获取父亲节点
- firstChild：获取第一个子节点
- lastChild：获取最后一个子节点
- firstElementChild / lastElementChild ：获取第一个和最后一个元素子节点 （不兼容IE6~8）
- previousSibling：获取上一个哥哥节点
- nextSibling：获取下一个弟弟节点
- previousElementSibling / nextElementSibling ：获取哥哥和弟弟元素节点（不兼容IE6~8）
- ......

#### 5、在JS中动态增删改元素

`createElement 创建元素对象` 

`createTextNode 创建文本对象`

`appendChild 把元素添加到容器的末尾`

`insertBefore 把元素添加到指定容器中指定元素的前面`

`removeChild 移除容器中的某个元素`
```javascript
// 动态创建一个DIV元素对象，把其赋给BOX
let box = document.createElement('div');
box.id = 'boxActive';
box.style.width = '200px';
box.style.height = '200px';
box.className = 'RED';

// 动态创建一个文本
let text = document.createTextNode('珠峰培训');

// 添加：容器.appendChild(元素)
box.appendChild(text);
// document.body.appendChild(box);

// 放到指定元素前：容器.insertBefore([新增元素],[指定元素])
let haha = document.getElementById('haha');
// haha.parentNode.insertBefore(...)
document.body.insertBefore(box, haha);
```

#### 6、克隆节点

`cloneNode(true/false) 克隆元素或者节点`

`removeChild 移除容器中的某个元素`

```html
<div class="box">
    <span>珠峰培训1</span>
</div>
<script>
    let box1 = document.querySelector('.box');
    // 克隆第一份（深克隆）
    let box2 = box1.cloneNode(true);
    box2.querySelector('span').innerText = '珠峰培训2';
    // 克隆第二份（浅克隆）
    let box3 = box1.cloneNode(false);
    box3.innerHTML = "<span>珠峰培训3</span>";

    document.body.appendChild(box2);
    document.body.appendChild(box3);

    //===========
    // 容器.removeChild(元素)
    document.body.removeChild(box2);
</script>
```

#### 7、自定义属性的在节点中设置的方法
`setAttribute / getAttribute / removeAttribute 设置获取移除元素的自定义属性信息（这种方式是把自定义属性放到元素结构上）`

```javascript
var btnList = document.querySelectorAll('button');
for (var i = 0; i < btnList.length; i++) {
	// 设置自定义属性：元素对象.属性名=属性值（原理是向元素对象对应的堆内存中添加了一个属性）
	// btnList[i].myIndex = i;

	// 设置自定义属性：基于SET-ATTRIBUTE是把属性信息写到了元素标签的结构上（在结构中可以看到的），并没有放到元素对象对应的堆内存中
	btnList[i].setAttribute('data-index', i);
	btnList[i].onclick = function () {
		// 获取自定义属性：元素对象.属性名 （原理是从堆内存中获取到对应的属性值）
		// alert(this.myIndex);

		// 基于GET-ATTRIBUTE可以把结构上存储的自定义属性值获取
		alert(this.getAttribute('data-index'));
	}
}
```